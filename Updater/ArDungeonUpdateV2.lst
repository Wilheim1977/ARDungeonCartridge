mads 2.1.0 build 8 (23 Dec 19)
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
     1 				.macro PUT_VERSION
     2 					.sb "V14"
     3 				.endm
     4
     5
     6 				;	@com.wudsn.ide.asm.outputfileextension=.atr
     7
     8
     9 				; include files, useful macros:
    10 					icl "../base/sys_equates.m65"
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\..\base\sys_equates.m65
     1 				;================================================================================
     2 				; System equates, Atari XL + mads [NRV 2009]
     3 				;================================================================================
     4
     5 				;----------------------------------------
     6 				; GTIA:
     7 				;----------------------------------------
     8
     9 = D000			M0PF	= $D000  ; read only
    10 = D001			M1PF	= $D001  ; read only
    11 = D002			M2PF	= $D002  ; read only
    12 = D003			M3PF	= $D003  ; read only
    13
    14 = D004			P0PF	= $D004  ; read only
    15 = D005			P1PF	= $D005  ; read only
    16 = D006			P2PF	= $D006  ; read only
    17 = D007			P3PF	= $D007  ; read only
    18
    19 = D008			M0PL	= $D008  ; read only
    20 = D009			M1PL	= $D009  ; read only
    21 = D00A			M2PL	= $D00A  ; read only
    22 = D00B			M3PL	= $D00B  ; read only
    23
    24 = D00C			P0PL	= $D00C  ; read only
    25 = D00D			P1PL	= $D00D  ; read only
    26 = D00E			P2PL	= $D00E  ; read only
    27 = D00F			P3PL	= $D00F  ; read only
    28
    29 = D010			TRIG0	= $D010  ; read only
    30 = D011			TRIG1	= $D011  ; read only
    31 = D012			TRIG2	= $D012  ; read only
    32 = D013			TRIG3	= $D013  ; read only
    33
    34 = D014			PAL		= $D014  ; read only
    35
    36 				; positions for normal screen: 48 left (+160)--> 208 right (or 32-->224 for wide playfield)
    37 				; 32 top (+192)--> 224 bottom (or 16-->112 for double line resolution)
    38 = D000			HPOSP0	= $D000  ; write only
    39 = D001			HPOSP1	= $D001  ; write only
    40 = D002			HPOSP2	= $D002  ; write only
    41 = D003			HPOSP3	= $D003  ; write only
    42
    43 = D004			HPOSM0	= $D004  ; write only
    44 = D005			HPOSM1	= $D005  ; write only
    45 = D006			HPOSM2	= $D006  ; write only
    46 = D007			HPOSM3	= $D007  ; write only
    47
    48 				; 0 (or 2) normal width, 1 double width, 4 quadruple width
    49 = D008			SIZEP0	= $D008  ; write only
    50 = D009			SIZEP1	= $D009  ; write only
    51 = D00A			SIZEP2	= $D00A  ; write only
    52 = D00B			SIZEP3	= $D00B  ; write only
    53
    54 = D00C			SIZEM	= $D00C  ; write only		// the same 2 bits as the players, but in one byte, in this order: m3m2m1m0
    55
    56 = D00D			GRAFP0	= $D00D  ; write only
    57 = D00E			GRAFP1	= $D00E  ; write only
    58 = D00F			GRAFP2	= $D00F  ; write only
    59 = D010			GRAFP3	= $D010  ; write only
    60
    61 = D011			GRAFM	= $D011  ; write only		// 4 missiles in this order: m3m2m1m0
    62
    63 = D012			COLPM0	= $D012  ; write only
    64 = D013			COLPM1	= $D013  ; write only
    65 = D014			COLPM2	= $D014  ; write only
    66 = D015			COLPM3	= $D015  ; write only
    67
    68 = D016			COLPF0	= $D016  ; write only
    69 = D017			COLPF1	= $D017  ; write only
    70 = D018			COLPF2	= $D018  ; write only
    71 = D019			COLPF3	= $D019  ; write only
    72
    73 = D01A			COLBK	= $D01A  ; write only
    74
    75 = D01B			PRIOR	= $D01B  ; write only
    76 = D01C			VDELAY	= $D01C  ; write only
    77 = D01D			GRACTL	= $D01D  ; write only
    78 = D01E			HITCLR	= $D01E  ; write only
    79
    80 = D01F			CONSOL	= $D01F  ; read and write
    81
    82 				;----------------------------------------
    83 				; POKEY:
    84 				;----------------------------------------
    85
    86 = D200			POT0	= $D200  ; read only
    87 = D201			POT1	= $D201  ; read only
    88 = D202			POT2	= $D202  ; read only
    89 = D203			POT3	= $D203  ; read only
    90 = D204			POT4	= $D204  ; read only
    91 = D205			POT5	= $D205  ; read only
    92 = D206			POT6	= $D206  ; read only
    93 = D207			POT7	= $D207  ; read only
    94
    95 = D208			ALLPOT	= $D208  ; read only
    96
    97 = D209			KBCODE	= $D209  ; read only
    98 = D20A			RANDOM	= $D20A  ; read only
    99
   100 = D20D			SERIN	= $D20D  ; read only
   101 = D20E			IRQST	= $D20E  ; read only
   102 = D20F			SKSTAT	= $D20F  ; read only
   103
   104
   105 = D200			AUDF1	= $D200  ; write only
   106 = D201			AUDC1	= $D201  ; write only
   107 = D202			AUDF2	= $D202  ; write only
   108 = D203			AUDC2	= $D203  ; write only
   109 = D204			AUDF3	= $D204  ; write only
   110 = D205			AUDC3	= $D205  ; write only
   111 = D206			AUDF4	= $D206  ; write only
   112 = D207			AUDC4	= $D207  ; write only
   113
   114 = D208			AUDCTL	= $D208  ; write only
   115
   116 = D209			STIMER	= $D209  ; write only
   117 = D20A			SKREST	= $D20A  ; write only
   118 = D20B			POTGO	= $D20B  ; write only
   119
   120 = D20D			SEROUT	= $D20D  ; write only
   121 = D20E			IRQEN	= $D20E  ; write only
   122 = D20F			SKCTL	= $D20F  ; write only
   123
   124 				;----------------------------------------
   125 				; PIA:
   126 				;----------------------------------------
   127
   128 = D300			PORTA	= $D300  ; read and write
   129 = D301			PORTB	= $D301  ; read and write
   130 = D302			PACTL	= $D302  ; read and write
   131 = D303			PBCTL	= $D303  ; read and write
   132
   133 				;----------------------------------------
   134 				; ANTIC:
   135 				;----------------------------------------
   136
   137 = D40B			VCOUNT	= $D40B  ; read only
   138
   139 = D40C			PENH	= $D40C  ; read only
   140 = D40D			PENV	= $D40D  ; read only
   141
   142 = D40F			NMIST	= $D40F  ; read only
   143
   144
   145 = D400			DMACTL	= $D400  ; write only
   146 = D401			CHACTL	= $D401  ; write only
   147 = D402			DLISTL	= $D402  ; write only
   148 = D403			DLISTH	= $D403  ; write only
   149 = D404			HSCROL	= $D404  ; write only
   150 = D405			VSCROL	= $D405  ; write only
   151 = D407			PMBASE	= $D407  ; write only
   152 = D409			CHBASE	= $D409  ; write only
   153 = D40A			WSYNC	= $D40A  ; write only
   154 = D40E			NMIEN	= $D40E  ; write only
   155 = D40F			NMIRES	= $D40F  ; write only
   156
   157 				;----------------------------------------
   158 				; Shadow registers:
   159 				;----------------------------------------
   160
   161 = 0218			CDTMV1	= $218
   162 = 021A			CDTMV2	= $21a
   163 = 021C			CDTMV3	= $21c
   164 = 021E			CDTMV4	= $21e
   165 = 0220			CDTMV5	= $220
   166
   167
   168 = 022F			SDMCTL	= $22f	; shadow of DMACTL
   169 = 026F			GPRIOR	= $26f	; shadow of PRIOR
   170
   171 = 02C0			PCOLR0	= $2c0	; shadow of COLPM0
   172 = 02C1			PCOLR1  = $2c1
   173 = 02C2			PCOLR2  = $2c2
   174 = 02C3			PCOLR3  = $2c3
   175 = 02C4			COLOR0	= $2c4	; shadow of COLPF0
   176 = 02C5			COLOR1  = $2c5
   177 = 02C6			COLOR2  = $2c6
   178 = 02C7			COLOR3  = $2c7
   179 = 02C8			COLOR4  = $2c8
   180
   181 = 02E0			RUNAD	= $2e0
   182 = 02E2			INITAD	= $2e2
   183
   184 = 0014			RTCLOCK	= $14
   185 = 0041			SOUNDR	= $41
   186 = 0042			CRITIC	= $42
   187 = 004D			ATRACT	= 77
   188
   189 = 0052			LMARGN = $52
   190 = 0053			RMARGN = $53
   191 = 0062			PALNTS = $62
   192 = 006A			RAMTOP = $6A
   193
   194 = 02F4			CHBAS	= $2F4	; shadow of CHBASE
   195 = 02FC			CH	= $2FC
   196 = 02F3			CHACT	= $2F3  ; 
   197
   198 = 0340			ICHID = $340
   199 = 0341			ICDNO = $341
   200 = 0342			ICCMD = $342
   201 = 0343			ICSTA = $343
   202 = 0344			ICBAL = $344
   203 = 0345			ICBAH = $345
   204 = 0346			ICPTL = $346
   205 = 0347			ICPTH = $347
   206 = 0348			ICBLL = $348
   207 = 0349			ICBLH = $349
   208 = 034A			ICAX1 = $34A
   209 = 034B			ICAX2 = $34B
   210
   211 = 03F8			BASICF  = $3f8
   212 = 03FA			GINTLK  = $3fa
   213
   214
   215 = 0230			SDLSTL	= $230	; display list address
   216 = 0200			VDSLST	= $200	; DLI address
   217
   218 = 0300			DDEVIC	= $300
   219 = 0301			DUNIT	= $301
   220 = 0302			DCOMND	= $302
   221 = 0303			DSTATS	= $303
   222 = 0304			DBUFLO	= $304
   223 = 0305			DBUFHI	= $305
   224
   225 = 030A			DAUX1	= $30A
   226 = 030B			DAUX2	= $30B
   227
   228
   229 = 0270			PADDL0	= 624	; 0-228 , shadow of POT0
   230 = 027C			PTRIG0	= 636	; 0 = PRESSED , shadow of PTRG0
   231 = 0278			STICK0	= 632	; 0000 = RLDU , shadow of PORTA
   232 = 0284			STRIG0	= 644	; 0 = PRESSED , shadow of TRIG0
   233
   234 = 0244			COLDST	= $244	; non zero --> do a cold start when pressing the reset key
   235
   236 				;----------------------------------------
   237 				; VBI:
   238 				;----------------------------------------
   239
   240 = E45C			SETVBV			= $E45C
   241 = E45F			XITVB_I			= $E45F
   242 = E45F			SYSVBV			= $E45F
   243 = E462			XITVB_D			= $E462
   244 = E462			XITVBV			= $E462
   245 = 0006			VBI_I			= 6
   246 = 0007			VBI_D			= 7
   247 = C0E2			NORMAL_VBI_I	= 49378
   248 = C28A			NORMAL_VBI_D	= 49802
   249 = 0222			VVBLKI			= 546
   250 = 0224			VVBLKD			= 548
   251 = E462			XITVB			= XITVB_D
   252
   253 				;----------------------------------------
   254 				; Handler vectors:
   255 				;----------------------------------------
   256
   257 = FFFA			NMIH_VECTOR		= 65530
   258 = FFFC			RESH_VECTOR		= 65532
   259 = FFFE			IRQH_VECTOR		= 65534
   260
   261 				;----------------------------------------
   262 				; I/O:
   263 				;----------------------------------------
   264
   265 = E453			DSKINV			= $E453 ; (58451)
   266 = E456			CIOV			= $E456	; (58454)
   267 = E459			SIOV			= $E459	; (58457)
   268
   269 				;----------------------------------------
   270 				; Restart routines
   271 				;----------------------------------------
   272
   273 = E474			WARMSV			= $E474
   274 = E477			COLDSV			= $E477
   275
   276 				;----------------------------------------
   277 				; Bit values:
   278 				;----------------------------------------
   279
   280 				; DMA values
   281 = 0020			DV_DMA_ON			= %00100000
   282 = 0010			DV_PM_ONE_LINE		= %00010000
   283 = 0008			DV_PLAYERS_ON		= %00001000
   284 = 0004			DV_MISSILES_ON		= %00000100
   285 = 0003			DV_WIDE_PF			= %00000011
   286 = 0002			DV_NORMAL_PF		= %00000010
   287 = 0001			DV_NARROW_PF		= %00000001
   288
   289 				; Display list values
   290 = 0080			DL_DLI_MASK		= %10000000
   291 = 0040			DL_LMS_MASK		= %01000000
   292 = 0020			DL_VSCROLL_MASK	= %00100000
   293 = 0010			DL_HSCROLL_MASK	= %00010000
   294
   295 = 0001			DL_JMP		= 1
   296 = 0041			DL_JVB		= 65
   297
   298 = 0000			DL_BLANK_1	= 0
   299 = 0010			DL_BLANK_2	= 16
   300 = 0020			DL_BLANK_3	= 32
   301 = 0030			DL_BLANK_4	= 48
   302 = 0040			DL_BLANK_5	= 64
   303 = 0050			DL_BLANK_6	= 80
   304 = 0060			DL_BLANK_7	= 96
   305 = 0070			DL_BLANK_8	= 112
   306
   307 				; Antic graphic modes
   308 = 0002			GM_CHAR_A2	= 2			; 2 colors, 40x24, 960b, 40xline, 8 scanlines
   309 = 0006			GM_CHAR_A6	= 6			; 4 colors, 20x24, 480b, 40xline, 8 scanlines
   310 = 0007			GM_CHAR_A7	= 7			; 4 colors, 20x12, 240b, 20xline, 16 scanlines
   311 = 0004			GM_CHAR_A4	= 4			; 5 colors, 40x24, 960b, 40xline, 8 scanlines
   312 = 0005			GM_CHAR_A5	= 5			; 5 colors, 40x12, 480b, 40xline, 16 scanlines
   313 = 0003			GM_CHAR_A3	= 3			; 2 colors, 40x24, 760b, 40xline, 10 scanlines
   314
   315 				; Basic graphic modes
   316 = 0002			GM_CHAR_G0	= 2			; 2 colors, 40x24, 960b, 40xline, 8 scanlines
   317 = 0006			GM_CHAR_G1	= 6			; 4 colors, 20x24, 480b, 40xline, 8 scanlines
   318 = 0007			GM_CHAR_G2	= 7			; 4 colors, 20x12, 240b, 20xline, 16 scanlines
   319 = 0004			GM_CHAR_G12	= 4			; 5 colors, 40x24, 960b, 40xline, 8 scanlines
   320 = 0005			GM_CHAR_G13	= 5			; 5 colors, 40x12, 480b, 40xline, 16 scanlines
   321
   322 = 0008			GM_PIXEL_G3	= 8			; 4 colors, 40x24, 240b, 10xline, 8 scanline
   323 = 0009			GM_PIXEL_G4	= 9			; 2 colors, 80x48, 480b, 10xline, 4 scanline
   324 = 000A			GM_PIXEL_G5	= 10		; 4 colors, 80x48, 960b, 20xline, 4 scanline
   325 = 000B			GM_PIXEL_G6	= 11		; 2 colors, 160x96, 1920b, 20xline, 2 scanline
   326 = 000D			GM_PIXEL_G7	= 13		; 4 colors, 160x96, 3840b, 40xline, 2 scanline
   327 = 000F			GM_PIXEL_G8	= 15		; 2 colors, 320x192, 7680b, 40xline, 1 scanline
   328 = 000C			GM_PIXEL_G14	= 12	; 2 colors, 160x192, 3840b, 20xline, 1 scanline
   329 = 000E			GM_PIXEL_G15	= 14	; 4 colors, 160x192, 7680b, 40xline, 1 scanline
   330
   331 = 000F			GM_PIXEL_G9	= 15		; 1 color, 80x192, 7680b, 40xline, 1 scanline
   332 = 000F			GM_PIXEL_G10	= 15	; 9 colors, 80x192, 7680b, 40xline, 1 scanline
   333 = 000F			GM_PIXEL_G11	= 15	; 16 colors, 80x192, 7680b, 40xline, 1 scanline
   334
   335 				; Prior values
   336 = 0001			PRV_PM_PRIORITY_1	= %00000001		; p0 p1 p2 p3 / pf0 pf1 pf2 pf3 (p5) / bk
   337 = 0002			PRV_PM_PRIORITY_2	= %00000010		; p0 p1 / pf0 pf1 pf2 pf3 (p5) / p2 p3 / bk
   338 = 0004			PRV_PM_PRIORITY_3	= %00000100		; pf0 pf1 pf2 pf3 (p5) /  p0 p1 p2 p3 / bk
   339 = 0008			PRV_PM_PRIORITY_4	= %00001000		; pf1 pf2 /  p0 p1 p2 p3 / pf0 pf3 (p5) / bk
   340 = 0010			PRV_FIFTH_PLAYER	= %00010000
   341 = 0020			PRV_PM_OVERLAP		= %00100000
   342 = 0040			PRV_GTIA_9			= %01000000
   343 = 0080			PRV_GTIA_10			= %10000000
   344 = 00C0			PRV_GTIA_11			= %11000000
   345
   346 				; Gractl values
   347 = 0001			GCTL_MISSILES		= %001
   348 = 0002			GCTL_PLAYERS		= %010
   349 = 0004			GCTL_LATCH_TRIGGERS	= %100
   350
   351 				; Consol values:
   352 = 0001			CNV_START_MASK		= %001
   353 = 0002			CNV_OPTION_MASK		= %010
   354 = 0004			CNV_SELECT_MASK		= %100
   355
   356 				; Stick values:
   357 = 0008			STV_RIGHT_MASK		= %1000
   358 = 0004			STV_LEFT_MASK		= %0100
   359 = 0002			STV_DOWN_MASK		= %0010
   360 = 0001			STV_UP_MASK			= %0001
   361
   362 = 0008			STICK_MASK_RIGHT	= %1000
   363 = 0004			STICK_MASK_LEFT		= %0100
   364 = 0002			STICK_MASK_DOWN		= %0010
   365 = 0001			STICK_MASK_UP		= %0001
   366
   367 = 0007			STICK_VALUE_RIGHT	= %0111
   368 = 000B			STICK_VALUE_LEFT	= %1011
   369 = 000D			STICK_VALUE_DOWN	= %1101
   370 = 000E			STICK_VALUE_UP		= %1110
   371
   372 				/*
   373 				KBCode Hexadecimal Values
   374 				 	$00	$01	$02	$03	$04	$05	$06	$07	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
   375 				$00	L	J	;	F1	F2	K	+	*	O	 	P	U	CR	I	-	=
   376 				$10	V	Hlp	C	F3	F4	B	X	Z	4	 	3	6	Esc	5	2	1
   377 				$20	,	Spc	.	N	 	M	/	Inv	R	 	E	Y	Tab	T	W	Q
   378 				$30	9	 	0	7	BS	8	<	>	F	H	D	 	Cap	G	S	A
   379
   380 				together with Shift Key: add +$40
   381 				together with Control key: add +$80 
   382 				*/
   382
    11 					icl "../base/sys_macros.m65"
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\..\base\sys_macros.m65
     1 				;================================================================================
     2 				; System macros, Atari XL + mads [NRV 2009]
     3 				;================================================================================
     4
     5 				;--------------------------------------------------------------------------------
     6 				; SetVector [address] [word]
     7 				;--------------------------------------------------------------------------------
     8
     9 					.macro SetVector
    10 					   .if :0 <> 2
    11 					      .error "SetVector error"
    12 				
    13 					   .else
    14 					      lda #<:2
    15 					      sta :1
    16 					      lda #>:2
    17 					      sta :1+1
    18 					   .endif
    19 				
    20 					.endm
    21
    22
    23 				;--------------------------------------------------------------------------------
    24 				; SetColor [0..4] [0..255]
    25 				; SetColor [0..4] [0..15] [0..15]
    26 				;--------------------------------------------------------------------------------
    27
    28 					.macro SetColor
    29 					   .if :0 < 2 .or :0 > 3
    30 					      .error "SetColor error"
    31 				
    32 					   .else
    33 					      .if :0 = 2
    34 					          lda #:2
    35 					          sta COLPF0+:1
    36 					      .else
    37 					          lda #[:2 * 16 + :3]
    38 					          sta COLPF0+:1
    39 					      .endif
    40 					   .endif
    41 				
    42 					.endm
    43
    44
    45 				;--------------------------------------------------------------------------------
    46 				; SetPMColor [0..3] [0..255]
    47 				; SetPMColor [0..3] [0..15] [0..15]
    48 				;--------------------------------------------------------------------------------
    49
    50 					.macro SetPMColor
    51 					   .if :0 < 2 .or :0 > 3
    52 					      .error "SetPMColor error"
    53 				
    54 					   .else
    55 					      .if :0 = 2
    56 					          lda #:2
    57 					          sta COLPM0+:1
    58 					      .else
    59 					          lda #[:2 * 16 + :3]
    60 					          sta COLPM0+:1
    61 					      .endif
    62 					   .endif
    63 				
    64 					.endm
    65
    66
    67 				;--------------------------------------------------------------------------------
    68 				; VcountSync [0..130]
    69 				; (maximum limit is different on PAL: 155)
    70 				; (could wait forever if there are interrupts activated!)
    71 				; (or if some other "thread" uses "wsync")
    72 				;--------------------------------------------------------------------------------
    73
    74 					.macro VcountSync
    75 					   .if :0 <> 1
    76 					      .error "VcountSync error"
    77 				
    78 					   .else
    79 					      sta WSYNC
    80 				
    81 					      lda #:1
    82 				VSync1	 cmp VCOUNT
    83 					      bne VSync1
    84 				
    85 					      lda #:1+1
    86 				VSync2	 cmp VCOUNT
    87 					      bne VSync2
    88 				
    89 					      sta WSYNC
    90 					   .endif
    91 				
    92 					.endm
    93
    94
    95 				;--------------------------------------------------------------------------------
    96 				; VcountWait [0..130]
    97 				; (maximum limit is different on PAL: 155)
    98 				;--------------------------------------------------------------------------------
    99
   100 					.macro VcountWait
   101 					   .if :0 <> 1
   102 					      .error "VcountWait error"
   103 				
   104 					   .else
   105 					      lda #:1
   106 				VWait1	 cmp VCOUNT
   107 					      bne VWait1
   108 					   .endif
   109 				
   110 					.endm
   111
   112
   113 				;--------------------------------------------------------------------------------
   114 				; VcountWaitUntilEnter [0..129] [(p1+1)..130]
   115 				; (maximum limit is different on PAL: 155)
   116 				;--------------------------------------------------------------------------------
   117
   118 					.macro VcountWaitUntilEnter
   119 					   .if :0 <> 2 .or :1 >= :2
   120 					      .error "VcountWaitUntilEnter error"
   121 				
   122 					   .else
   123 				VWait1     lda VCOUNT
   124 						 cmp #:1
   125 						 beq VExit
   126 					      bcc VWait1	; VCOUNT < :1
   127 						 cmp #:2
   128 						 beq VExit
   129 					      bcs VWait1	; VCOUNT >= :2
   130 				VExit
   131 					   .endif
   132 				
   133 					.endm
   134
   135
   136 				;--------------------------------------------------------------------------------
   137 				; VcountWaitUntilExit [0..129] [(p1+1)..130]
   138 				; (maximum limit is different on PAL: 155)
   139 				;--------------------------------------------------------------------------------
   140
   141 					.macro VcountWaitUntilExit
   142 					   .if :0 <> 2 .or :1 >= :2
   143 					      .error "VcountWaitUntilExit error"
   144 				
   145 					   .else
   146 				VWait1     lda VCOUNT
   147 						 cmp #:1
   148 						 beq VWait1
   149 					      bcc VExit	; VCOUNT < :1
   150 						 cmp #:2
   151 					      bcc VWait1	; VCOUNT < :2
   152 						 beq VWait1
   153 				VExit
   154 					   .endif
   155 				
   156 					.endm
   157
   158
   159 				;--------------------------------------------------------------------------------
   160 				; MarkScanLine [0..255] [0..255]
   161 				; (mark the current scan line with a color)
   162 				;--------------------------------------------------------------------------------
   163
   164 					.macro MarkScanLine
   165 					   .if :0 <> 0 .and :0 <> 2
   166 					      .error "MarkScanLine error"
   167 				
   168 					   .else
   169 					  	   .if :0 = 0
   170 				  		      sta WSYNC
   171 				  	     	 lda #255		; mark color
   172 					  	      sta COLBK
   173 				
   174 				  		      sta WSYNC
   175 				  	     	 lda #0		; restore color
   176 					  	      sta COLBK
   177 				
   178 				  		   .else
   179 					     	 sta WSYNC
   180 						      lda #:1		; mark color
   181 						      sta COLBK
   182 				
   183 						      sta WSYNC
   184 						      lda #:2		; restore color
   185 					     	 sta COLBK
   186 						   .endif
   187 					   .endif
   188 				
   189 					.endm
   190
   191
   192 				;--------------------------------------------------------------------------------
   193 				; MarkScanLineIfConsol [0..255] [0..255]
   194 				; (mark the current scan line with a color, if a consol key is pressed)
   195 				;--------------------------------------------------------------------------------
   196
   197 					.macro MarkScanLineIfConsol
   198 					   .if :0 <> 0 .and :0 <> 2
   199 					      .error "MarkScanLineIfConsol error"
   200 				
   201 					   .else
   202 						 .if :0 = 0
   203 						      lda CONSOL
   204 						      and #%111
   205 					     	 cmp #%111
   206 						      beq ExitMarkScanLineIfConsol
   207 				
   208 						      sta WSYNC
   209 						      lda #255		; mark color
   210 						      sta COLBK
   211 				
   212 						      sta WSYNC
   213 						      lda #0		; restore color
   214 					     	 sta COLBK
   215 				
   216 					   	 .else
   217 						      lda CONSOL
   218 						      and #%111
   219 					     	 cmp #%111
   220 						      beq ExitMarkScanLineIfConsol
   221 				
   222 						      sta WSYNC
   223 					     	 lda #:1		; mark color
   224 						      sta COLBK
   225 				
   226 						      sta WSYNC
   227 					     	 lda #:2		; restore color
   228 						      sta COLBK
   229 				
   230 					   	 .endif
   231 					   .endif
   232 				
   233 				ExitMarkScanLineIfConsol
   234 				
   235 					.endm
   236
   237
   238 				;--------------------------------------------------------------------------------
   239 				; MarkCyclesIfConsol [0..255] [0..255]
   240 				; (mark the current scan position with a color, for some cycles)
   241 				;--------------------------------------------------------------------------------
   242
   243 					.macro MarkCyclesIfConsol
   244 					   .if :0 = 0
   245 					      lda CONSOL
   246 					      and #%111
   247 					      cmp #%111
   248 					      beq ExitMarkCyclesIfConsol
   249 				
   250 					      lda #255		; mark color
   251 					      sta COLBK
   252 				
   253 					      lda ($00),y	; dummy 5 cycles
   254 					      lda ($00),y	; dummy 5 cycles
   255 					      lda ($00),y	; dummy 5 cycles
   256 					      lda ($00),y	; dummy 5 cycles
   257 					      lda ($00),y	; dummy 5 cycles
   258 					      lda ($00),y	; dummy 5 cycles
   259 				
   260 					      lda #0		; restore color
   261 					      sta COLBK
   262 				
   263 					   .elseif :0 = 2
   264 					      lda CONSOL
   265 					      and #%111
   266 					      cmp #%111
   267 					      beq ExitMarkCyclesIfConsol
   268 				
   269 					      lda #:1		; mark color
   270 					      sta COLBK
   271 				
   272 					      lda ($00),y	; dummy 5 cycles
   273 					      lda ($00),y	; dummy 5 cycles
   274 					      lda ($00),y	; dummy 5 cycles
   275 					      lda ($00),y	; dummy 5 cycles
   276 					      lda ($00),y	; dummy 5 cycles
   277 					      lda ($00),y	; dummy 5 cycles
   278 				
   279 					      lda #:2		; restore color
   280 					      sta COLBK
   281 				
   282 					   .else
   283 					      .error "MarkCyclesIfConsol error"
   284 				
   285 					   .endif
   286 				
   287 				ExitMarkCyclesIfConsol
   288 				
   289 					.endm
   290
   291
   292 				;--------------------------------------------------------------------------------
   293 				; SetBasic [0,1]
   294 				;--------------------------------------------------------------------------------
   295
   296 					.macro SetBasic
   297 					   .if :0 <> 1
   298 					      .error "SetBasic error"
   299 				
   300 					   .else
   301 					      .if :1 = 0
   302 					         lda PORTB	; deactivate Basic
   303 					         ora #%00000010
   304 					         sta PORTB
   305 					      .else
   306 					         lda PORTB	; activate Basic
   307 					         and #%11111101
   308 					         sta PORTB
   309 					      .endif
   310 					   .endif
   311 				
   312 					.endm
   313
   314
   315 				;--------------------------------------------------------------------------------
   316 				; SetOperativeSystem [0,1]
   317 				;--------------------------------------------------------------------------------
   318
   319 					.macro SetOperativeSystem
   320 					   .if :0 <> 1
   321 					      .error "SetOperativeSystem error"
   322 				
   323 					   .else
   324 					      .if :1 = 0
   325 					         lda PORTB	; deactivate Operative System
   326 					         and #%11111110
   327 					         sta PORTB
   328 					      .else
   329 					         lda PORTB	; activate Operative System
   330 					         ora #%00000001
   331 					         sta PORTB
   332 					      .endif
   333 					   .endif
   334 				
   335 					.endm
   336
   337
   338 				;--------------------------------------------------------------------------------
   339 				; EnableBasic
   340 				;--------------------------------------------------------------------------------
   341
   342 					.macro EnableBasic
   343 					   .if :0 <> 0
   344 					      .error "EnableBasic error"
   345 				
   346 					   .else
   347 					      SetBasic 1
   348 					   .endif
   349 				
   350 					.endm
   351
   352
   353 				;--------------------------------------------------------------------------------
   354 				; DisableBasic
   355 				;--------------------------------------------------------------------------------
   356
   357 					.macro DisableBasic
   358 					   .if :0 <> 0
   359 					      .error "DisableBasic error"
   360 				
   361 					   .else
   362 					      SetBasic 0
   363 					   .endif
   364 				
   365 					.endm
   366
   367
   368 				;--------------------------------------------------------------------------------
   369 				; EnableOperativeSystem
   370 				;--------------------------------------------------------------------------------
   371
   372 					.macro EnableOperativeSystem
   373 					   .if :0 <> 0
   374 					      .error "EnableOperativeSystem error"
   375 				
   376 					   .else
   377 					      SetOperativeSystem 1
   378 					   .endif
   379 				
   380 					.endm
   381
   382
   383 				;--------------------------------------------------------------------------------
   384 				; DisableOperativeSystem
   385 				;--------------------------------------------------------------------------------
   386
   387 					.macro DisableOperativeSystem
   388 					   .if :0 <> 0
   389 					      .error "DisableOperativeSystem error"
   390 				
   391 					   .else
   392 					      SetOperativeSystem 0
   393 					   .endif
   394 				
   395 					.endm
   396
   397
   398 				;--------------------------------------------------------------------------------
   399 				; EnableNormalInterrupts
   400 				;--------------------------------------------------------------------------------
   401
   402 					.macro EnableNormalInterrupts
   403 					   .if :0 <> 0
   404 					      .error "EnableNormalInterrupts error"
   405 				
   406 					   .else
   407 					      cli
   408 				;	      lda #[8+16+32]	; serial I/O interrupts
   409 				;	      lda #[64+128]		; keyboard and break interrupts (only ones enabled on powerup)
   410 				;	      sta IRQEN
   411 					      lda #64			; VBI interrupt
   412 					      sta NMIEN
   413 					   .endif
   414 				
   415 					.endm
   416
   417
   418 				;--------------------------------------------------------------------------------
   419 				; DisableNormalInterrupts
   420 				;--------------------------------------------------------------------------------
   421
   422 					.macro DisableNormalInterrupts
   423 					   .if :0 <> 0
   424 					      .error "DisableNormalInterrupts error"
   425 				
   426 					   .else
   427 					      sei
   428 					      lda #0
   429 					      sta IRQEN
   430 					      sta NMIEN
   431 					   .endif
   432 				
   433 					.endm
   434
   435
   436 				;--------------------------------------------------------------------------------
   437 				; ClearSystem
   438 				;--------------------------------------------------------------------------------
   439
   440 					.macro ClearSystem
   441 					   .if :0 <> 0
   442 					      .error "ClearSystem error"
   443 				
   444 					   .else
   445 					      clc
   446 					      cld
   447 				
   448 					      sei
   449 				
   450 					      lda #0
   451 					      sta IRQEN	; clear interrupts and screen
   452 					      sta NMIEN
   453 				
   454 					      sta DMACTL
   455 					      sta COLBK
   456 				
   457 					      sta GRACTL	; clear P/M
   458 					      sta GRAFP0
   459 					      sta GRAFP1
   460 					      sta GRAFP2
   461 					      sta GRAFP3
   462 					      sta GRAFM
   463 				
   464 					      sta HPOSP0
   465 					      sta HPOSP1
   466 					      sta HPOSP2
   467 					      sta HPOSP3
   468 					      sta HPOSM0
   469 					      sta HPOSM1
   470 					      sta HPOSM2
   471 					      sta HPOSM3
   472 				
   473 					      sta PRIOR	; clear GTIA also
   474 				
   475 					      sta AUDCTL	; clear sound
   476 					      sta AUDC1
   477 					      sta AUDC2
   478 					      sta AUDC3
   479 					      sta AUDC4
   480 				
   481 					      lda #3
   482 					      sta SKCTL
   483 					   .endif
   484 				
   485 					.endm
   486
   487
   488 				;--------------------------------------------------------------------------------
   489 				; SetDisplayListAddress [word]
   490 				; (use when the screen is not being displayed!)
   491 				; (remember to not cross the 1K limit..)
   492 				;--------------------------------------------------------------------------------
   493
   494 					.macro SetDisplayListAddress
   495 					   .if :0 <> 1
   496 					      .error "SetDisplayListAddress error"
   497 				
   498 					   .else
   499 					      SetVector DLISTL, :1
   500 				
   501 				;	      lda #<:1
   502 				;	      sta DLISTL
   503 				;	      lda #>:1
   504 				;	      sta DLISTH
   505 					   .endif
   506 				
   507 					.endm
   508
   509
   510 				;--------------------------------------------------------------------------------
   511 				; SetFontAddress [word]
   512 				; (remember that this transform to a page a number)
   513 				;--------------------------------------------------------------------------------
   514
   515 					.macro SetFontAddress
   516 					   .if :0 <> 1
   517 					      .error "SetFontAddress error"
   518 				
   519 					   .else
   520 					      lda #>:1
   521 					      sta CHBASE
   522 					   .endif
   523 				
   524 					.endm
   525
   526
   527 				;--------------------------------------------------------------------------------
   528 				; SetPMBaseAddress [word]
   529 				; (remember that this transform to a page a number)
   530 				;--------------------------------------------------------------------------------
   531
   532 					.macro SetPMBaseAddress
   533 					   .if :0 <> 1
   534 					      .error "SetPMBaseAddress error"
   535 				
   536 					   .else
   537 					      lda #>:1
   538 					      sta PMBASE
   539 					   .endif
   540 				
   541 					.endm
   542
   543
   544 				;--------------------------------------------------------------------------------
   545 				; SetMemory [address] [bytes] [value]
   546 				;--------------------------------------------------------------------------------
   547
   548 				; warning, using some page zero memory
   549
   550 					.macro SetMemory
   551 				
   552 				setMemPtr	= 254
   553 				setMemCounter	= 252
   554 				
   555 					   .if :0 <> 3
   556 					      .error "SetMemory error"
   557 				
   558 					   .else
   559 					      ldy #0
   560 				
   561 					      lda #<:1
   562 					      sta setMemPtr
   563 					      lda #>:1
   564 					      sta setMemPtr+1
   565 				
   566 					      .if :2 < 256
   567 					         lda #:3
   568 				setMemLoop1
   569 					         sta (setMemPtr),y
   570 					         iny
   571 					         cpy #:2
   572 					         bne setMemLoop1
   573 				
   574 					      .else
   575 					         lda #<:2
   576 					         sta setMemCounter
   577 					         lda #>:2
   578 					         sta setMemCounter+1
   579 				
   580 				setMemLoop2
   581 					         lda #:3
   582 					         sta (setMemPtr),y
   583 					         iny
   584 					         bne setMemB1
   585 					         inc setMemPtr+1
   586 				setMemB1
   587 					         lda setMemCounter
   588 					         bne setMemB2
   589 					         dec setMemCounter+1
   590 				setMemB2
   591 					         dec setMemCounter
   592 				
   593 					         lda setMemCounter
   594 					         ora setMemCounter+1
   595 					         bne setMemLoop2
   596 					      .endif
   597 					   .endif
   598 				
   599 					.endm
   600
   601
   602 				;--------------------------------------------------------------------------------
   603 				; SetMemoryRandom [address] [bytes]
   604 				;--------------------------------------------------------------------------------
   605
   606 				; warning, using some page zero memory
   607
   608 					.macro SetMemoryRandom
   609 				
   610 				setMemRPtr	= 254
   611 				setMemRCounter	= 252
   612 				
   613 					   .if :0 <> 2
   614 					      .error "SetMemoryRandom error"
   615 				
   616 					   .else
   617 					      ldy #0
   618 				
   619 					      lda #<:1
   620 					      sta setMemRPtr
   621 					      lda #>:1
   622 					      sta setMemRPtr+1
   623 				
   624 					      .if :2 < 256
   625 				setMemRLoop1
   626 					         lda RANDOM
   627 					         sta (setMemRPtr),y
   628 					         iny
   629 					         cpy #:2
   630 					         bne setMemRLoop1
   631 				
   632 					      .else
   633 					         lda #<:2
   634 					         sta setMemRCounter
   635 					         lda #>:2
   636 					         sta setMemRCounter+1
   637 				
   638 				setMemRLoop2
   639 					         lda RANDOM
   640 					         sta (setMemRPtr),y
   641 					         iny
   642 					         bne setMemRB1
   643 					         inc setMemRPtr+1
   644 				setMemRB1
   645 					         lda setMemRCounter
   646 					         bne setMemRB2
   647 					         dec setMemRCounter+1
   648 				setMemRB2
   649 					         dec setMemRCounter
   650 				
   651 					         lda setMemRCounter
   652 					         ora setMemRCounter+1
   653 					         bne setMemRLoop2
   654 					      .endif
   655 					   .endif
   656 				
   657 					.endm
   658
   659
   660 				;--------------------------------------------------------------------------------
   661 				; ClampMemory [address] [bytes] [min value] [max value]
   662 				;--------------------------------------------------------------------------------
   663
   664 				; warning, using some page zero memory
   665
   666 					.macro ClampMemory
   667 				
   668 				clampMemPtr	= 254
   669 				clampMemCounter	= 252
   670 				
   671 					   .if :0 <> 4
   672 					      .error "ClampMemory error"
   673 				
   674 					   .else
   675 					      ldy #0
   676 				
   677 					      lda #<:1
   678 					      sta clampMemPtr
   679 					      lda #>:1
   680 					      sta clampMemPtr+1
   681 				
   682 					      .if :2 < 256
   683 				clampMemLoop1
   684 					         lda (clampMemPtr),y
   685 					         cmp #:3
   686 					         bcs clampMemB3		; if >= min then continue
   687 					         lda #:3
   688 					         jmp clampMemB4
   689 				clampMemB3
   690 					         cmp #:4
   691 					         bcc clampMemB4		; if < max then continue
   692 				;	         beq clampMemB4		; if = max then continue
   693 					         lda #:4
   694 				clampMemB4
   695 					         sta (clampMemPtr),y
   696 				
   697 					         iny
   698 					         cpy #:2
   699 					         bne clampMemLoop1
   700 				
   701 					      .else
   702 					         lda #<:2
   703 					         sta clampMemCounter
   704 					         lda #>:2
   705 					         sta clampMemCounter+1
   706 				
   707 				clampMemLoop2
   708 					         lda (clampMemPtr),y
   709 					         cmp #:3
   710 					         bcs clampMemB5		; if >= min then continue
   711 					         lda #:3
   712 					         jmp clampMemB6
   713 				clampMemB5
   714 					         cmp #:4
   715 					         bcc clampMemB6		; if < max then continue
   716 				;	         beq clampMemB6		; if = max then continue
   717 					         lda #:4
   718 				clampMemB6
   719 					         sta (clampMemPtr),y
   720 				
   721 					         iny
   722 					         bne clampMemB1
   723 					         inc clampMemPtr+1
   724 				clampMemB1
   725 					         lda clampMemCounter
   726 					         bne clampMemB2
   727 					         dec clampMemCounter+1
   728 				clampMemB2
   729 					         dec clampMemCounter
   730 				
   731 					         lda clampMemCounter
   732 					         ora clampMemCounter+1
   733 					         bne clampMemLoop2
   734 					      .endif
   735 					   .endif
   736 				
   737 					.endm
   738
   739
   740 				;--------------------------------------------------------------------------------
   741 				; AndMemory [address] [bytes] [value]
   742 				;--------------------------------------------------------------------------------
   743
   744 				; warning, using some page zero memory
   745
   746 					.macro AndMemory
   747 				
   748 				andMemPtr	= 254
   749 				andMemCounter	= 252
   750 				
   751 					   .if :0 <> 3
   752 					      .error "AndMemory error"
   753 				
   754 					   .else
   755 					      ldy #0
   756 				
   757 					      lda #<:1
   758 					      sta andMemPtr
   759 					      lda #>:1
   760 					      sta andMemPtr+1
   761 				
   762 					      .if :2 < 256
   763 				andMemLoop1
   764 					         lda (andMemPtr),y
   765 					         and #:3
   766 					         sta (andMemPtr),y
   767 					         iny
   768 					         cpy #:2
   769 					         bne andMemLoop1
   770 				
   771 					      .else
   772 					         lda #<:2
   773 					         sta andMemCounter
   774 					         lda #>:2
   775 					         sta andMemCounter+1
   776 				
   777 				andMemLoop2
   778 					         lda (andMemPtr),y
   779 					         and #:3
   780 					         sta (andMemPtr),y
   781 					         iny
   782 					         bne andMemB1
   783 					         inc andMemPtr+1
   784 				andMemB1
   785 					         lda andMemCounter
   786 					         bne andMemB2
   787 					         dec andMemCounter+1
   788 				andMemB2
   789 					         dec andMemCounter
   790 				
   791 					         lda andMemCounter
   792 					         ora andMemCounter+1
   793 					         bne andMemLoop2
   794 					      .endif
   795 					   .endif
   796 				
   797 					.endm
   798
   799
   800 				;--------------------------------------------------------------------------------
   801 				; CopyMemory [source address] [dest address] [bytes]
   802 				;--------------------------------------------------------------------------------
   803
   804 				; warning, using some page zero memory
   805
   806 					.macro CopyMemory
   807 				
   808 				copyMemPtr1	= 254
   809 				copyMemPtr2	= 252
   810 				copyMemCounter	= 250
   811 				
   812 					   .if :0 <> 3
   813 					      .error "CopyMemory error"
   814 				
   815 					   .else
   816 					      ldy #0
   817 				
   818 					      .if :3 <= 256
   819 				copyMemLoop1
   820 						lda :1,y
   821 						sta :2,y
   822 						iny
   823 						.if :3 < 256
   824 							cpy #<:3
   825 						.endif
   826 						bne copyMemLoop1
   827 				
   828 					      .else
   829 					        lda #<:1
   830 					        sta copyMemPtr1
   831 					        lda #>:1
   832 					        sta copyMemPtr1+1
   833 						lda #<:2
   834 						sta copyMemPtr2
   835 						lda #>:2
   836 						sta copyMemPtr2+1
   837 						lda #<:3
   838 						sta copyMemCounter
   839 						lda #>:3
   840 						sta copyMemCounter+1
   841 				
   842 				copyMemLoop2
   843 						lda (copyMemPtr1),y
   844 						sta (copyMemPtr2),y
   845 						iny
   846 						bne copyMemB1
   847 						inc copyMemPtr1+1
   848 						inc copyMemPtr2+1
   849 				copyMemB1
   850 						lda copyMemCounter
   851 						bne copyMemB2
   852 						dec copyMemCounter+1
   853 				copyMemB2
   854 						dec copyMemCounter
   855 				
   856 						lda copyMemCounter
   857 						ora copyMemCounter+1
   858 						bne copyMemLoop2
   859 					      .endif
   860 					   .endif
   861 				
   862 					.endm
   863
   864
   865 				;--------------------------------------------------------------------------------
   866 				; CreateDisplayList [DL address] [DL mode] [memory address]
   867 				; (remember to not cross the 1K limit.. and the 4K limit)
   868 				;--------------------------------------------------------------------------------
   869
   870 				; 	.macro CreateDisplayList
   871 				; 	   .if :0 <> 3
   872 				; 	      .error "CreateDisplayList error"
   873 				; 
   874 				; 	   .else
   875 				; 
   876 				; 	   .endif
   877 				; 
   878 				; 	.endm
   879
   880
   881 				;--------------------------------------------------------------------------------
   882 				;
   883 				;--------------------------------------------------------------------------------
   884
   885
   886
    12
    13
    14 = 2000			start_data =$2000
    15 				//start_cartridge =$a000
    16 = 2000			cart_length =$2000
    17 = 6000			buffer = $6000
    18 = D5FF			cart_off =$D5FF
    19
    20 = 0040			write_enable = $40
    21 = 0004			write_enable2 = $04
    22
    23 = 0013			dir_lines = 19
    24 = 0026			num_files = dir_lines*2
    25
    26 = 00CB			pt_1 = $cb
    27 = 00CD			pt_2 = $cd
    28 = 00CF			pt_3 = $cf
    29
    30 = 0000			starting_bank 	= $00
    31 = 004F			final_bank		= $4f
    32 = 0050			total_banks		= final_bank-starting_bank+1
    33 = 0000			starting_sector	= starting_bank/8
    34 = 000A			total_sectors	= (total_banks+7)/8
    35
    36
    37
    38
    39
    40 					opt h-
    41 					
    42 				//Let's do the ATR Header
    43
    44 = 0A0780			Total_Size		= (((end_atr - start_data)+127)/128)*128
    45 = 0000			Total_Size_high	= (Total_Size/$100000)
    46 = A078			Total_Size_low	= (Total_Size-(Total_Size_high*$100000))/$10
    47
    48 = 000F			Sectors_boot	= (end_program-start_data+127)/128
    49
    50 = 0010			init_sector		= Sectors_boot + 1
    51 				;init_rom_sector	= (init_sector + (starting_bank*$40))
    52 = 0010			init_rom_sector	= init_sector
    53
    54  96 02				.by $96,$02				//Checksum of "NICKATARI"
    55  78 A0				.word Total_Size_low	//Total bytes
    56  80 00				.word $80				//Sector Size
    57  00 00				.word Total_Size_high	//Total bytes
    58  00				.by $00					//No Write Protect nor Bad sectors.
    59  00 00				.word $00				//No bad sectors
    60  00 00 00 00 00			.by $00,$00,$00,$00,$00
    61
    62
    63 					org start_data
    64 					
    65 2000 00				.by $00
    66 2001 0F				.by Sectors_boot
    67 2002 00 20			.word start_data
    68 2004 64 26			.word start
    69 2006			init_boot
    70 2006 18				clc
    71 2007 60				rts	
    72
    73
    74 				// Include Flash drivers	
    75 2008				icl "FlashCartDriver.asm"
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\FlashCartDriver.asm
     1
     2 				//Flash cartridge driver
     3 				//2021 Guillermo Fuenzalida
     4 				//
     5
     6
     7 = A000			start_cartridge = $a000
     8 = C000			end_cartridge	= $c000
     9 = 0010			num_tries	= $10
    10
    11 				//	org $2000
    12
    13 2008			chip_select
    14 2008 00				.by $00	
    15
    16 				//SetSector: selects the first bank of the sector selected.
    17 				//Parameter: A= number of sector ($00-$0F)	
    18 2009			.proc SetSector
    19 2009 29 0F			and #$0F	//Only $00-$0F allowed
    20 200B 18				clc		//Just to not set bit 7 to 1 accidentally
    21 200C 0A				asl		//*2
    22 200D 0A				asl		//*4
    23 200E 0A				asl		//*8
    24 200F AA				tax
    25 2010 9D 00 D5			sta $d500,x	//Change bank!
    26 2013 60				rts
    27 				.endp
    28
    29
    30 				//Command_Unlock: first two steps to unlock the flash chip.
    31 2014			.proc Command_Unlock
    32 2014 A9 AA			lda #$AA
    33 2016 20 AE 21			jsr Write_5555
    34 2019 A9 55			lda #$55
    35 201B 4C 9B 21			jmp Write_2AAA
    36
    37 				.endp
    38
    39 201E			.proc CheckID
    40 201E 8E 44 20			stx save_x+1
    41 2021 20 14 20			jsr Command_Unlock
    42 2024 A9 90			lda #$90
    43 2026 20 AE 21			jsr Write_5555
    44 2029 AE 08 20			ldx chip_select
    45 202C 9D 00 D5			sta $d500,x
    46 202F AD 00 A0			lda $a000
    47 2032 0D 01 A0			ora $a001
    48 2035 48				pha
    49 2036 20 14 20			jsr Command_Unlock
    50 2039 A9 F0			lda #$f0
    51 203B 20 AE 21			jsr Write_5555
    52 203E A2 00			ldx #$00
    53 2040			loop
    54 2040 E8				inx
    55 2041 D0 FD			bne loop
    56
    57 2043			save_x
    58 2043 A2 00			ldx #$00
    59 2045 68				pla
    60 2046 60				rts
    61 				.endp
    62
    63 				//is39F: looks if chipset if sst39sf040.
    64 				//Output: Carry set = is sst39sf040, carry clear = none of this.
    65 2047			.proc is39F
    66 2047 20 1E 20			jsr CheckID
    67 204A C9 BF			cmp #$bf
    68 204C D0 02			bne no_sst
    69 204E 38				sec
    70 204F 60				rts
    71 2050			no_sst
    72 2050 18				clc
    73 2051 60				rts
    74 				.endp
    75
    76
    77 				// VerifyBlankSector: verifies if sector is erased ($FF)
    78 				// Parameter A=Sector number (0 to 15)
    79 				// Output: Carry clear = OK, Carry Set = Error
    80 2052			.proc VerifyBlankSector
    81
    82 = D500			bank	= $d500
    83 = 00CB			pt_1	= $cb
    84 = 00CD			pt_2	= $cd
    85
    86 2052 48				pha
    87 2053 8E 91 20			stx save_x+1	//save X register
    88 2056 8C 93 20			sty save_y+1	//save Y register
    89 2059 18				clc				//By default, we are ok
    90 205A A0 00			ldy #$00
    91 205C 0A 0A 0A			:3 asl 			//*8
    92 205F AA				tax				//Save bank on X
    93 2060 A9 08 8D 96 20		mva #$08 count
    94
    95 2065			loop1
    96 2065 9D 00 D5			sta bank,x		//Activate bank
    97 2068 A9 00 8D 73 20 A9 + 	mwa #start_cartridge loop2+1	//init the loop with start_cartridge
    98 2072			loop2
    99 2072 B9 FF FF			lda $ffff,y
   100 2075 C9 FF			cmp #$ff
   101 2077 D0 16			bne error
   102 2079 C8				iny
   103 207A D0 F6			bne loop2
   104 207C EE 74 20			inc loop2+2
   105 207F AD 74 20			lda loop2+2
   106 2082 C9 C0			cmp #>end_cartridge
   107 2084 D0 EC			bne loop2
   108 2086 E8				inx
   109 2087 CE 96 20			dec count
   110 208A D0 D9			bne loop1
   111 208C 18				clc
   112 208D 90 01			bcc end_loop
   113 208F			error
   114 208F 38				sec
   115 2090			end_loop
   116
   117 2090			save_x
   118 2090 A2 00			ldx #$00
   119 2092			save_y
   120 2092 A0 00			ldy #$00
   121 2094 68				pla
   122 2095			end_verify
   123 2095 60				rts
   124 2096			count
   125 2096 00				.by $00
   126 				.endp
   127
   128
   129 				//Erase_Cartridge: erases an entire cartridge
   130 				//Parameter: none
   131
   132 2097			.proc Erase_cartridge
   133 2097 48				pha
   134 2098 A9 00			lda #$00
   135 209A 8D 08 20			sta chip_select
   136 209D			begin_erase
   137 209D 20 14 20			jsr Command_Unlock
   138 20A0 A9 80			lda #$80
   139 20A2 20 AE 21			jsr Write_5555
   140 20A5 A9 AA			lda #$aa
   141 20A7 20 AE 21			jsr Write_5555
   142 20AA A9 55			lda #$55
   143 20AC 20 9B 21			jsr Write_2aaa
   144 20AF A9 10			lda #$10
   145 20B1 20 AE 21			jsr Write_5555
   146 20B4 20 5B 21			jsr pollwrite
   147 20B7 AD 08 20			lda chip_select
   148 20BA D0 07			bne end_erase
   149 20BC A9 40			lda #$40
   150 20BE 8D 08 20			sta chip_select
   151 20C1 D0 DA			bne begin_erase
   152 20C3			end_erase
   153 20C3 A9 00			lda #$00
   154 20C5 8D 08 20			sta chip_select
   155 20C8 68				pla
   156 20C9 60				rts
   157 				.endp
   158
   159 				//EraseSector: erases sector of 64kbytes
   160 				//Parameter: A=sector to erase 
   161 20CA			.proc Erase_Sector
   162 20CA 48				pha		//Save sector
   163 20CB 29 08			and #$08
   164 20CD F0 02			beq erase2
   165 20CF A9 40			lda #$40
   166 20D1			erase2
   167 20D1 8D 08 20			sta chip_select
   168 					
   169 20D4 20 47 20			jsr is39f
   170 20D7 B0 26			bcs erase3
   171
   172 20D9 20 47 21			jsr Common
   173
   174 20DC 68				pla		//Recover sector
   175 20DD 48				pha
   176 20DE 20 09 20			jsr SetSector
   177 					
   178 					
   179 20E1 A9 30			lda #$30
   180 20E3 8D 00 A0			sta start_cartridge	//6th cycle
   181
   182 				//Erase command sent. Now let's wait until it's finished.
   183
   184 20E6 A9 10 8D 59 21		mva #num_tries sec_count
   185 					
   186 20EB 68				pla
   187 20EC 48				pha
   188 					
   189 20ED			loop
   190 					
   191 20ED 20 5B 21			jsr pollwrite
   192 					
   193 20F0 68				pla
   194 20F1 48				pha
   195 					
   196 20F2 20 52 20			jsr VerifyBlankSector
   197 20F5 90 06			bcc exit
   198 20F7 CE 59 21			dec sec_count
   199 20FA D0 F1			bne loop
   200 20FC 38				sec
   201 20FD			exit
   202 20FD 68				pla
   203 20FE 60				rts
   204
   205 20FF			erase3
   206 20FF 8E 42 21			stx save_x+1
   207 2102 8C 44 21			sty save_y+1
   208 2105 A9 08 8D 59 21		mva #$08 sec_count
   209
   210 210A 68				pla
   211 210B 48				pha
   212 210C 0A				asl
   213 210D 0A				asl
   214 210E 0A				asl
   215 210F 8D 5A 21			sta bank_number
   216
   217 2112			loop2	
   218 2112 20 47 21			jsr Common
   219 2115 AE 5A 21			ldx bank_number
   220 2118 9D 00 D5			sta $d500,x
   221 211B A9 30			lda #$30
   222 211D 8D 00 A0			sta start_cartridge
   223 2120 20 5B 21			jsr pollwrite
   224 					
   225 2123 20 47 21			jsr Common
   226 2126 AE 5A 21			ldx bank_number
   227 2129 9D 00 D5			sta $d500,x
   228 212C A9 30			lda #$30
   229 212E 8D 00 B0			sta start_cartridge+$1000
   230 2131 20 7B 21			jsr pollwrite2
   231 2134 EE 5A 21			inc bank_number
   232 2137 CE 59 21			dec sec_count
   233 213A D0 D6			bne loop2
   234 213C 68				pla
   235 213D 48				pha
   236 213E 20 52 20			jsr VerifyBlankSector
   237 2141			save_x
   238 2141 A2 00			ldx #$00
   239 2143			save_y
   240 2143 A0 00			ldy #$00	
   241 2145 68				pla
   242 2146 60				rts
   243
   244 2147			Common
   245 2147 20 14 20			jsr Command_Unlock //1st and 2nd cycle
   246 					
   247 214A A9 80			lda #$80
   248 214C 20 AE 21			jsr Write_5555	//3rd cycle
   249 214F A9 AA			lda #$aa
   250 2151 20 AE 21			jsr Write_5555	//4th cycle
   251 2154 A9 55			lda #$55
   252 2156 4C 9B 21			jmp Write_2aaa	//5th cycle
   253 					
   254
   255 2159			sec_count
   256 2159 00				.by $00
   257 215A			bank_number
   258 215A 00				.by $00
   259
   260 				.endp
   261
   262
   263 				//PollWrite: waits until the sector data stopped changing.
   264 215B			.proc pollwrite
   265
   266 = A000			byte_address = start_cartridge
   267
   268 215B 48				pha
   269 215C			again
   270 215C A9 00 8D 7A 21		mva #$00 pollsame
   271 2161			loop
   272 2161 AD 00 A0			lda byte_address
   273 2164 CD 00 A0			cmp byte_address
   274 2167 D0 F3			bne again
   275 2169 CD 00 A0			cmp byte_address
   276 216C D0 EE			bne again
   277 216E CD 00 A0			cmp byte_address
   278 2171 D0 E9			bne again
   279 2173 EE 7A 21			inc pollsame
   280 2176 D0 E9			bne loop
   281 2178 68				pla
   282 2179 60				rts
   283 217A			pollsame
   284 217A 00				.by $00
   285 				.endp
   286
   287 217B			.proc pollwrite2
   288
   289 = B000			byte_address = start_cartridge+$1000
   290
   291 217B 48				pha
   292 217C			again
   293 217C A9 00 8D 9A 21		mva #$00 pollsame
   294 2181			loop
   295 2181 AD 00 B0			lda byte_address
   296 2184 CD 00 B0			cmp byte_address
   297 2187 D0 F3			bne again
   298 2189 CD 00 B0			cmp byte_address
   299 218C D0 EE			bne again
   300 218E CD 00 B0			cmp byte_address
   301 2191 D0 E9			bne again
   302 2193 EE 9A 21			inc pollsame
   303 2196 D0 E9			bne loop
   304 2198 68				pla
   305 2199 60				rts
   306 219A			pollsame
   307 219A 00				.by $00
   308 				.endp
   309
   310 				//Write_2aaa: writes value at $2aaa on the respective chip selected.
   311 				//Parameter: A=value to write
   312 219B			.proc write_2aaa
   313 219B 2C 08 20			bit chip_select
   314 219E 50 07			bvc step2
   315 21A0 8D 41 D5			sta $d541
   316 21A3 8D AA AA			sta $aaaa
   317 21A6 60				rts
   318 21A7			step2
   319 21A7 8D 01 D5			sta $d501
   320 21AA 8D AA AA			sta $aaaa
   321 21AD 60				rts
   322 				.endp
   323
   324 21AE			.proc write_5555
   325 21AE 2C 08 20			bit chip_select
   326 21B1 50 07			bvc step2
   327 21B3 8D 42 D5			sta $d542
   328 21B6 8D 55 B5			sta $b555
   329 21B9 60				rts
   330 21BA			step2
   331 21BA 8D 02 D5			sta $d502
   332 21BD 8D 55 B5			sta $b555
   333 21C0 60				rts
   334 				.endp
   335
   336 				//Enable Write: enables one byte to write on the cartridge
   337 				//Parameter: A = bank to write.
   338
   339 21C1			.proc Enable_Write
   340 21C1 8E E1 21			stx save_x+1
   341 21C4 48				pha					//Save bank to write on.
   342 21C5 29 7F			and #$7f			//Avoid error on using banks >=128
   343 21C7 4A 4A 4A			:3 lsr				//divide by 8
   344 21CA 29 08			and #$08
   345 21CC F0 02			beq erase2
   346 21CE A9 40			lda #$40
   347 21D0			erase2
   348 21D0 8D 08 20			sta chip_select
   349 21D3 20 14 20			jsr Command_Unlock	//1st and 2nd cycle
   350 21D6 A9 A0			lda #$a0
   351 21D8 20 AE 21			jsr Write_5555		//3rd cycle
   352 21DB 68				pla					//Recover bank
   353 21DC AA				tax
   354 21DD 9D 00 D5			sta $d500,x
   355 21E0			save_x
   356 21E0 A2 00			ldx #$00
   357 21E2 60				rts
   358 				.endp
   359
   360
   361 				//Erase_Sectors: erase a number of sectors
   362 				//Parameters: X=Initial sector, Y=number of sectors to erase.
   363 21E3			.proc Erase_Sectors
   364 21E3 48				pha		//Save accumulator
   365 21E4 8E FA 21			stx sector
   366 21E7 8C FB 21			sty num_sectors
   367 21EA			loop
   368 21EA AD FA 21			lda sector
   369 21ED 20 CA 20			jsr Erase_Sector
   370 21F0 EE FA 21			inc sector
   371 21F3 CE FB 21			dec num_sectors
   372 21F6 D0 F2			bne loop
   373 21F8 68				pla
   374 21F9 60				rts
   375 21FA			sector
   376 21FA 00				.by $00
   377 21FB			num_sectors
   378 21FB 00				.by $00
   379 				.endp
   380
   381 				//VerifyBlankSectors: Verify status blank of sector
   382 				//Parameters: X=Initial sector, Y=number of sectors to verify.
   383 				//Output: Carry clear: OK, Carry Set = Error
   384 21FC			.proc VerifyBlankSectors
   385 21FC 48				pha
   386 21FD			loop
   387 21FD 8A				txa
   388 21FE 20 52 20			jsr VerifyBlankSector
   389 2201 B0 05			bcs end_verify
   390 2203 E8				inx
   391 2204 88				dey
   392 2205 D0 F6			bne loop
   393 2207 18				clc
   394 2208			end_verify
   395 2208 68				pla
   396 2209 60				rts
   397 					
   398 				.endp
    76
    77
    78 				//Determinamos macros
    79
    80 				//Partimos con seleccionar el banco
    81 				//Formato: banco x,y
    82 				//x = Cartridge bank to activate
    83 				//y= 0 if its for reading, Y=1 read/write
    84 				.macro banco
    85 				.if :0 <> 2 
    86 					.error "banco sin parmetros"
    87 				.else
    88 					.if :1 < 256
    89 						lda #:1
    90 						.if :2 = 1
    91 							ora #write_enable
    92 						.endif
    93 						tax
    94 						sta $d500,x
    95 					.else
    96 						lda :1
    97 						.if :2 = 1
    98 							;ora #write_enable
    99 							ora value_write
   100 						.endif
   101 						tax
   102 						sta $d500,x
   103 					.endif
   104 				.endif 
   105 				.endm
   106
   107 				//Realiza un print en la pantalla hasta encontrar un RETURN ($9b).
   108 				//Uso: print mem_addr
   109 				.macro print
   110 				.if :0 <> 1
   111 					.error "print sin parmetros"
   112 				.else
   113 					ldx #<:1
   114 					ldy #>:1
   115 					jsr pr
   116 				.endif
   117 				.endm
   118 					
   119
   120 				//print2: imprime una cantidad fija de caracteres segn un largo definido.
   121 				//Uso: print2 mem_addr, num_caracteres
   122 				.macro print2
   123 				.if :0 <> 2
   124 					.error "print2 sin parmetros"
   125 				.else
   126 					ldx #<:1
   127 					ldy #>:1
   128 					lda #:2
   129 					jsr pr2
   130 				.endif
   131 				.endm
   132
   133
   134
   135 				//Cierra el canal solicitado.
   136 				//Uso: close channel
   137 				.macro close
   138 				.if :0 <> 1
   139 					.error "close sin parmetros"
   140 				.else
   141 				;	lda #:1
   142 				;	:+4 asl
   143 				;	tax
   144 					ldx #(:1*16)
   145 					lda #$0C	//Close
   146 					sta ICCMD,x
   147 					jsr CIOV
   148 				.endif
   149 				.endm
   150
   151 				//Open: open CIO channel, simmilar to BASIC.
   152 				//Uso: open channel,operation,aux,loc_handler
   153
   154 				.macro open
   155 				.if :0 <> 4
   156 					.error "open sin parmetros"
   157 				.else
   158 				;	lda #:1
   159 				;	:+4 asl
   160 				;	tax
   161 					ldx #(:1*16)
   162 					mva #$03 ICCMD,x	//Open
   163 					mwa #:4	ICBAL,x		//"E:","C:","D:"
   164 					mva #:2	ICAX1,x		//Read and write
   165 					mva #:3 ICAX2,x
   166 					jsr CIOV
   167 				.endif
   168 				.endm
   169
   170 				//CopyM: Copy nmero de pginas de una direccin a otra.
   171 				.macro CopyM
   172 				//Restriccin: slo utiliza los bytes mayores. Para un movimiento ms fino, utilizar CopyMemory
   173 				
   174 				.if :0 <> 3
   175 					.error "CopyM sin parmetros correctos"
   176 				.else
   177 					ldx #>:1
   178 					ldy #>:2
   179 					lda #>:3
   180 					jsr copy
   181 				.endif
   182 				
   183 				
   184 				.endm
   185
   186 				//WriteMemory: Escribe en disco el contenido de memoria
   187 				//Parmetros:
   188 				//  1: Canal a escribir
   189 				//  2: Zona de memoria inicial a escribir
   190 				//  3: Cantidad de bytes
   191 				.macro WriteMemory
   192 				.if :0 <> 3
   193 					.error "WriteMemory sin parmetros correctos"
   194 				.else
   195 				;	lda #:1
   196 				;	:+4 asl
   197 				;	tax
   198 					ldx #(:1*16)
   199 					mwa #:2 ICBAL,x
   200 					mwa #:3 ICBLL,x
   201 					mva #11 ICCMD,X
   202 					jsr ciov
   203 				.endif
   204 				.endm
   205
   206 				//ReadDisk: lee del disco el contenido y guarda en memoria
   207 				//Parmetros:
   208 				//  1: Canal del cual leer
   209 				//  2: Zona de memoria al cual grabar
   210 				//  3: Cantidad de bytes
   211 				.macro ReadDisk
   212 				.if :0 <> 3
   213 					.error "ReadDisk sin parmetros correctos"
   214 				.else
   215 				;	lda #:1
   216 				;	:+4 asl
   217 				;	tax
   218 					ldx #(:1*16)
   219 					mwa #:2 ICBAL,x
   220 					mwa #:3 ICBLL,x
   221 					mva #7 ICCMD,X
   222 					jsr ciov
   223 				.endif
   224 				.endm
   225
   226
   227 				//WriteCart: Escribe en cartridge el contenido de memoria
   228 				//Parmetros:
   229 				//  1: Canal a escribir
   230 				//  2: Zona de memoria inicial a escribir
   231 				//  3: Cantidad de bytes
   232 				.macro WriteCart
   233 				.if :0 <> 3
   234 					.error "WriteCart sin parmetros correctos"
   235 				.else
   236 					ReadDisk :1,:2,:3
   237 					CopyM :2,start_cartridge,:3
   238 				.endif
   239 				.endm
   240
   241 				//input: realiza un input por CIO
   242 				//Uso: input canal,direccin a tomar
   243 				.macro input
   244 				.if :0 <> 2
   245 					.error "Input sin parmetros correctos"
   246 				.else
   247 				;	lda #:1
   248 				;	:+4 asl
   249 				;	tax
   250 					ldx #(:1*16)
   251 					mwa #:2 ICBAL,X		;Direccin entregada
   252 					mwa #20 ICBLL,x		;Mximo 20 bytes (Pueden ser ms)
   253 					mva #5 ICCMD,x		;Comando INPUT
   254 					jsr ciov		;Ejecute"
   255 				.endif
   256 				
   257 				.endm
   258
   259 				//get: realiza un input por CIO
   260 				//Uso: input canal,direccin a tomar
   261 				.macro get
   262 				.if :0 <> 2
   263 					.error "Get sin parmetros correctos"
   264 				.else
   265 				;	lda #:1
   266 				;	:+4 asl
   267 				;	tax
   268 					ldx #(:1*16)
   269 					mwa #:2 ICBAL,X		;Direccin entregada
   270 					mwa #1 ICBLL,x		;Cantidad de bytes = 1
   271 					mva #7 ICCMD,x		;Realizar una lectura
   272 					jsr ciov		;Ejecute!
   273 				.endif
   274 				
   275 				.endm
   276
   277
   278
   279 220A			boot_sector
   280 220A 00				.by $00
   281 220B 01				.by $01		//1 sector to read
   282 220C 00 06			.word $600
   283 220E 06 06			.word $606
   284 2210 38				sec
   285 2211 60				rts
   286 2212 00 00 00 00 00 00 + 	:120 .by $00
   287
   288 228A			LOC_E
   289 228A 45 3A 9B			.by "E:",$9B	;Handler editor E:
   290 228D			LOC_K
   291 228D 4B 3A 9B			.by "K:",$9B	;Handler keyboard
   292 2290			LOC_DISK
   293 2290 44 31 3A 41 41 41 + 	.by "D1:AAAAAAAA.DMP",$9B	;file name (not used now)
   294 22A0			LOC_DIR
   295 22A0 44 31 3A 2A 2E 2A + 	.by "D1:*.*",$9B		;search directory (not used)
   296 22A7			LOC_INPUT
   297 22A7 20 20 20 20 20 20 + 	.by "                    "
   298 22BB			dl
   299 22BB 70 70 70			.by $70,$70,$70
   300 22BE 70 70 70 70 70 70 + 	:7 .by $70
   301 22C5 30				.by $30
   302 22C6 42				.by $42				;Primera lnea modo ANTIC 2
   303 22C7 D0 22			.word screen
   304 22C9 02 02 02 02			:4 .by $02 			;4 lneas ms
   305 				//	.by $70
   306 				//	.by $02,$02,$02
   307 22CD 41				.by $41				;Vuelva
   308 22CE BB 22			.word dl			;al display list!
   309 					
   310
   311 22D0			screen
   312 22D0 51 52 52 52 52 52 + 	.sb +32,"QRRRRRRRRRRRRRRRRRRRRRRRWRRRRRRRRRRRRRRE"
   313 22F8 7C 21 32 00 24 75 + 	.sb     "|AR Dungeon Updater "
   314 230C				PUT_VERSION
Macro: PUT_VERSION [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm]
     1 230C 36 11 14			.sb "V14"
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   315 230F 00 7C 12 10 12 11 + 	.sb " |2021 Willysoft|"
   316 2320 41 52 52 52 52 52 + 	.sb +32,"ARRRRRRRRRRRWRRRRRRRRRRRXRRRRRRRRRRRRRRD"
   317 2348 7C				.sb     "|"
   318 2349 B3 B4 A1 B2 B4		.sb +128,"START"
   319 234E 1A				.sb      ":"
   320 234F			screen_start
   321 234F 22 25 27 29 2E		.sb "BEGIN"
   322 2354			screen_start_end
   323
   324 2354			screen_status
   325 2354 7C 00 00 00 00 00 + 	.sb "|                          |"
   326 2370			screen_status_end
   327 = 001C			len_screen_status = screen_status_end - screen_status
   328
   329 2370 5A 52 52 52 52 52 + 	.sb +32,"ZRRRRRRRRRRRXRRRRRRRRRRRRRRRRRRRRRRRRRRC"
   330
   331 2398			screen_erasing
   332 2398 7C 25 72 61 73 69 + 	.sb "|Erasing Cartridge...      |"
   333 23B4			screen_erasing_end
   334 = 001C			len_screen_erasing = screen_erasing_end - screen_erasing
   335
   336 23B4			screen_veryfing
   337 23B4 7C 36 65 72 69 66 + 	.sb "|Verifying erase...        |"
   338 23D0			screen_veryfing_end
   339 = 001C			len_screen_veryfing = screen_veryfing_end - screen_veryfing
   340
   341 23D0			screen_reading
   342 23D0 7C 32 65 61 64 69 + 	.sb "|Reading Bank     "
   343 23E2			screen_reading_bank
   344 23E2 10 10 0F			.sb "00/"
   345 23E5			screen_reading_total_banks
   346 23E5 17 26 00 00 00 00 + 	.sb "7F    |"
   347 23EC			screen_reading_end
   348 = 001C			len_screen_reading = screen_reading_end - screen_reading
   349
   350 23EC			screen_writing
   351 23EC 7C 37 72 69 74 69 + 	.sb "|Writing Bank     "
   352 23FE			screen_writing_bank
   353 23FE 10 10 0F			.sb "00/"
   354 2401			screen_writing_total_banks
   355 2401 17 26 00 00 00 00 + 	.sb "7F    |"
   356 2408			screen_writing_end
   357 = 001C			len_screen_writing = screen_writing_end - screen_writing
   358
   359 2408			screen_verify_write
   360 2408 7C 36 65 72 69 66 + 	.sb "|Verifying Bank   "
   361 241A			screen_verify_write_bank
   362 241A 10 10 0F			.sb "00/"
   363 241D			screen_verify_total_banks
   364 241D 17 26 00 00 00 00 + 	.sb "7F    |"
   365 2424			screen_verify_write_end
   366
   367 = 001C			len_screen_verify_write = screen_writing_end - screen_writing
   368
   369 2424			screen_done
   370 2424 7C 24 2F 2E 25 01 + 	.sb "|DONE!                     |"
   371 2440			screen_done_end
   372 = 001C			len_screen_done = screen_done_end - screen_done
   373
   374 2440			text_check
   375 2440 41 52 20 43 48 41 + 	.by "AR CHAR!"	//Header to check on disk or cartridge
   376 2448			text_check_end
   377 = 0008			len_text_check = text_check_end - text_check
   378
   379 2448			BEEP
   380 2448 FD				.by $FD		//Beep sound
   381
   382 2449			flag_busy
   383 2449 00				.by $00
   384
   385 244A			flag_operation
   386 244A 00				.by $00
   387 244B			flag_start
   388 244B 00				.by $00
   389
   390 244C			consol_previous
   391 244C 08				.by $08
   392
   393 244D			key
   394 244D 00				.by $00
   395 					
   396 244E			banknum
   397 244E 00				.by $00
   398 					
   399 244F			count
   400 244F 00				.by $00
   401 					
   402 2450			sector
   403 2450 00 00			.word $00
   404 					
   405 2452			tabla_hex
   406 2452 10 11 12 13 14 15 + 	.sb "0123456789ABCDEF"
   407 					
   408 2462			.proc put_banknum
   409 2462 AD 4E 24			lda banknum
   410 2465 4A 4A 4A 4A			:4 lsr
   411 2469 AA				tax
   412 246A BD 52 24			lda tabla_hex,x
   413 246D 8D E2 23			sta screen_reading_bank
   414 2470 8D FE 23			sta screen_writing_bank
   415 2473 8D 1A 24			sta screen_verify_write_bank
   416 2476 AD 4E 24			lda banknum
   417 2479 29 0F			and #$0f
   418 247B AA				tax
   419 247C BD 52 24			lda tabla_hex,x
   420 247F 8D E3 23			sta screen_reading_bank+1
   421 2482 8D FF 23			sta screen_writing_bank+1
   422 2485 8D 1B 24			sta screen_verify_write_bank+1
   423 2488 60				rts
   424 				.endp
   425
   426 2489			.proc put_final_bank
   427 2489 A9 4F			lda #final_bank
   428 248B 4A 4A 4A 4A			:4 lsr
   429 248F AA				tax
   430 2490 BD 52 24			lda tabla_hex,x
   431 2493 8D E5 23			sta screen_reading_total_banks
   432 2496 8D 01 24			sta screen_writing_total_banks
   433 2499 8D 1D 24			sta screen_verify_total_banks
   434 249C A9 4F			lda #final_bank
   435 249E 29 0F			and #$0f
   436 24A0 AA				tax
   437 24A1 BD 52 24			lda tabla_hex,x
   438 24A4 8D E6 23			sta screen_reading_total_banks+1
   439 24A7 8D 02 24			sta screen_writing_total_banks+1
   440 24AA 8D 1E 24			sta screen_verify_total_banks+1
   441 24AD 60				rts
   442 				.endp
   443
   444 					
   445 24AE			.proc put_erase
   446 24AE				CopyMemory screen_erasing,screen_status,len_screen_erasing
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 24AE A0 00			      ldy #0
    13 24B0			copyMemLoop1
    14 24B0 B9 98 23				lda SCREEN_ERASING,y
    15 24B3 99 54 23				sta SCREEN_STATUS,y
    16 24B6 C8					iny
    18 24B7 C0 1C					cpy #<LEN_SCREEN_ERASING
    20 24B9 D0 F5				bne copyMemLoop1
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   447 24BB 60				rts
   448 				.endp
   449
   450 24BC			.proc put_veryfing
   451 24BC				CopyMemory screen_veryfing,screen_status,len_screen_veryfing
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 24BC A0 00			      ldy #0
    13 24BE			copyMemLoop1
    14 24BE B9 B4 23				lda SCREEN_VERYFING,y
    15 24C1 99 54 23				sta SCREEN_STATUS,y
    16 24C4 C8					iny
    18 24C5 C0 1C					cpy #<LEN_SCREEN_VERYFING
    20 24C7 D0 F5				bne copyMemLoop1
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   452 24C9 60				rts
   453 				.endp
   454
   455 24CA			.proc put_reading
   456 24CA				CopyMemory screen_reading,screen_status,len_screen_reading
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 24CA A0 00			      ldy #0
    13 24CC			copyMemLoop1
    14 24CC B9 D0 23				lda SCREEN_READING,y
    15 24CF 99 54 23				sta SCREEN_STATUS,y
    16 24D2 C8					iny
    18 24D3 C0 1C					cpy #<LEN_SCREEN_READING
    20 24D5 D0 F5				bne copyMemLoop1
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   457 24D7 60				rts
   458 				.endp
   459
   460 24D8			.proc put_writing
   461 24D8				CopyMemory screen_writing,screen_status,len_screen_writing
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 24D8 A0 00			      ldy #0
    13 24DA			copyMemLoop1
    14 24DA B9 EC 23				lda SCREEN_WRITING,y
    15 24DD 99 54 23				sta SCREEN_STATUS,y
    16 24E0 C8					iny
    18 24E1 C0 1C					cpy #<LEN_SCREEN_WRITING
    20 24E3 D0 F5				bne copyMemLoop1
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   462 24E5 60				rts
   463 				.endp
   464
   465 24E6			.proc put_verify_write
   466 24E6				CopyMemory screen_verify_write,screen_status,len_screen_verify_write
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 24E6 A0 00			      ldy #0
    13 24E8			copyMemLoop1
    14 24E8 B9 08 24				lda SCREEN_VERIFY_WRITE,y
    15 24EB 99 54 23				sta SCREEN_STATUS,y
    16 24EE C8					iny
    18 24EF C0 1C					cpy #<LEN_SCREEN_VERIFY_WRITE
    20 24F1 D0 F5				bne copyMemLoop1
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   467 24F3 60				rts
   468 				.endp
   469
   470 24F4			.proc put_done
   471 24F4				CopyMemory screen_done,screen_status,len_screen_done
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 24F4 A0 00			      ldy #0
    13 24F6			copyMemLoop1
    14 24F6 B9 24 24				lda SCREEN_DONE,y
    15 24F9 99 54 23				sta SCREEN_STATUS,y
    16 24FC C8					iny
    18 24FD C0 1C					cpy #<LEN_SCREEN_DONE
    20 24FF D0 F5				bne copyMemLoop1
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   472 2501 60				rts
   473 				.endp
   474
   475 2502			.proc WriteM
   476 2502				WriteMemory 1,start_cartridge,cart_length
Macro: WRITEMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm]
     7 2502 A2 10			ldx #(1*16)
     8 2504 A9 00 9D 44 03 A9 + 	mwa #START_CARTRIDGE ICBAL,x
     9 250E A9 00 9D 48 03 A9 + 	mwa #CART_LENGTH ICBLL,x
    10 2518 A9 0B 9D 42 03		mva #11 ICCMD,X
    11 251D 20 56 E4			jsr ciov
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   477 2520 60				rts
   478 				.endp
   479
   480 2521			.proc get_key
   481 2521				get 1,key
Macro: GET [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm]
     7 2521 A2 10			ldx #(1*16)
     8 2523 A9 4D 9D 44 03 A9 + 	mwa #KEY ICBAL,X		;Direccin entregada
     9 252D A9 01 9D 48 03 A9 + 	mwa #1 ICBLL,x		;Cantidad de bytes = 1
    10 2537 A9 07 9D 42 03		mva #7 ICCMD,x		;Realizar una lectura
    11 253C 20 56 E4			jsr ciov		;Ejecute!
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   482 253F 60				rts
   483 				.endp
   484
   485 2540			.proc Erase_patch
   486 2540 A2 00			ldx #starting_sector
   487 2542 A0 0A			ldy #total_sectors
   488 2544 20 E3 21			jsr Erase_Sectors
   489 2547 60				rts
   490 				.endp
   491
   492 2548			.proc Verify_Erase
   493 2548 A2 00			ldx #starting_sector
   494 254A A0 0A			ldy #total_sectors
   495 254C 20 FC 21			jsr VerifyBlankSectors
   496 254F 60				rts
   497 				.endp
   498
   499 2550			.proc Read_bank
   500 2550 A9 31 8D 00 03		mva #$31 DDEVIC
   501 2555 A9 01 8D 01 03		mva #$01 DUNIT
   502 255A AD 50 24 8D 0A 03 + 	mwa sector $30A
   503 2566 A9 52 8D 02 03		mva #$52 dcomnd
   504 256B A9 00 8D 04 03 A9 + 	mwa #buffer dbuflo
   505 2575 A9 40 8D A7 25		mva #$40 count
   506 257A			loop
   507 257A 20 53 E4			jsr dskinv
   508 257D 30 FB			bmi loop
   509 257F EE 0A 03			inc daux1
   510 2582 D0 03			bne loop2
   511 2584 EE 0B 03			inc daux2
   512 2587			loop2
   513 2587 AD 04 03			lda dbuflo
   514 258A 18				clc
   515 258B 69 80			adc #$80
   516 258D 8D 04 03			sta dbuflo
   517 2590 90 03			bcc loop3
   518 2592 EE 05 03			inc dbufhi
   519 2595			loop3
   520 2595 CE A7 25			dec count
   521 2598 D0 E0			bne loop
   522 259A AD 0A 03 8D 50 24 + 	mwa daux1 sector
   523 25A6 60				rts
   524 25A7			count
   525 25A7 00				.by $00
   526 				.endp	
   527
   528 25A8			.proc Write_bank
   529 25A8 48				pha
   530 25A9 8A				txa
   531 25AA 48				pha
   532 25AB 98				tya
   533 25AC 48				pha
   534
   535 25AD A9 00 85 CB A9 60 + 	mwa #buffer pt_1
   536 25B5 A9 00 85 CD A9 A0 + 	mwa #start_cartridge pt_2
   537 25BD A0 00			ldy #$00
   538 25BF A2 20			ldx #$20
   539 25C1			loop
   540 25C1 AD 4E 24			lda banknum
   541 25C4 20 C1 21			jsr enable_write
   542 25C7 B1 CB			lda (pt_1),y
   543 25C9 91 CD			sta (pt_2),y
   544 25CB C8				iny
   545 25CC D0 F3			bne loop
   546 25CE E6 CC			inc pt_1+1
   547 25D0 E6 CE			inc pt_2+1
   548 25D2 CA				dex
   549 25D3 D0 EC			bne loop
   550
   551 25D5 68				pla
   552 25D6 A8				tay
   553 25D7 68				pla
   554 25D8 AA				tax
   555 25D9 68				pla
   556 25DA 60				rts
   557 				.endp
   558
   559 25DB			.proc Verify_Bank
   560 25DB 48				pha
   561 25DC 8A				txa
   562 25DD 48				pha
   563 25DE 98				tya
   564 25DF 48				pha
   565 25E0 A9 00 85 CB A9 A0 + 	mwa #start_cartridge pt_1
   566 25E8 A9 00 85 CD A9 60 + 	mwa #buffer pt_2
   567 25F0 A0 00			ldy #$00
   568 25F2 AD 4E 24			lda banknum
   569 25F5 AA				tax
   570 25F6 9D 00 D5			sta $d500,x
   571 25F9 A2 20			ldx #$20
   572 25FB			loop
   573 25FB B1 CB			lda (pt_1),y
   574 25FD D1 CD			cmp (pt_2),y
   575 25FF D0 0D			bne error
   576 2601 C8				iny
   577 2602 D0 F7			bne loop
   578 2604 E6 CC			inc pt_1+1
   579 2606 E6 CE			inc pt_2+1
   580 2608 CA				dex
   581 2609 D0 F0			bne loop
   582 260B 18				clc
   583 260C 90 01			bcc end_verify
   584 260E			error
   585 260E 38				sec
   586 260F			end_verify
   587 260F 68				pla
   588 2610 A8				tay
   589 2611 68				pla
   590 2612 AA				tax
   591 2613 68				pla
   592 2614 60				rts
   593 				.endp
   594
   595 2615			.proc wait_return
   596 2615			start
   597 2615 AD FC 02			lda CH
   598 2618 C9 FF			cmp #$ff	//Key pressed?
   599 261A D0 F9			bne start	//Nope, start over!
   600 261C 20 21 25			jsr get_key //Get key
   601 261F A9 FF			lda #$ff	//Erase last key pressed
   602 2621 8D FC 02			sta CH		//Done!
   603 2624 AD 4D 24			lda key		//Read key
   604 2627 C9 9B			cmp #$9b	//Is it Return?
   605 2629 D0 EA			bne start	//No, let's do it again.
   606 262B 60				rts			//Yes, return
   607 				.endp
   608
   609 262C			.proc Wait_sec
   610 262C A5 14			lda rtclock
   611 262E 18				clc
   612 262F 69 3C			adc #60
   613 2631			loop
   614 2631 C5 14			cmp rtclock
   615 2633 D0 FC			bne loop
   616 2635 60				rts
   617 				.endp
   618
   619
   620 2636			.proc vbi
   621 2636 AD 13 D0			lda trig3
   622 2639 8D FA 03			sta gintlk		//No cartridge lockup!
   623 263C A5 4D			lda atract
   624 263E 30 04			bmi vbi_end
   625 2640 A9 00			lda #$00
   626 2642 85 4D			sta atract
   627 2644			vbi_end
   628 2644 4C 5F E4			jmp sysvbv
   629 				.endp
   630
   631 2647			.proc vbd
   632 2647 AD 49 24			lda flag_busy
   633 264A D0 15			bne vbd_end
   634 264C AD 1F D0			lda consol
   635 264F CD 4C 24			cmp consol_previous
   636 2652 F0 0D			jeq vbd_end
   637 2654 8D 4C 24			sta consol_previous
   638 2657 4A				lsr		; START?
   639 2658 B0 07			bcs vbd_2	; No!
   640 265A 48				pha
   641
   642 265B A9 01			lda #$01
   643 265D 8D 4B 24			sta flag_start
   644
   645 2660 68				pla
   646 2661			vbd_2
   647 2661			vbd_end
   648 2661 4C 62 E4			jmp xitvbv
   649 				.endp
   650
   651 					
   652 2664			start
   653 				//	jsr screen_erase
   654 2664			start2
   655 2664 AD 01 D3			lda portb
   656 2667 09 FE			ora #$fe	//No BASIC, maintain SIO patch if there's any.
   657 2669 8D 01 D3			sta portb
   658 266C A9 01 8D F8 03		mva #$01 basicf
   659 2671				close 0
Macro: CLOSE [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm]
     7 2671 A2 00			ldx #(0*16)
     8 2673 A9 0C			lda #$0C	//Close
     9 2675 9D 42 03			sta ICCMD,x
    10 2678 20 56 E4			jsr CIOV
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   660 267B				close 1
Macro: CLOSE [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm]
     7 267B A2 10			ldx #(1*16)
     8 267D A9 0C			lda #$0C	//Close
     9 267F 9D 42 03			sta ICCMD,x
    10 2682 20 56 E4			jsr CIOV
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   661 2685 A9 A0 85 6A			mva #$a0 RAMTOP
   662 2689				open 0,12,0,LOC_E
Macro: OPEN [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm]
     7 2689 A2 00			ldx #(0*16)
     8 268B A9 03 9D 42 03		mva #$03 ICCMD,x	//Open
     9 2690 A9 8A 9D 44 03 A9 + 	mwa #LOC_E	ICBAL,x		//"E:","C:","D:"
    10 269A A9 0C 9D 4A 03		mva #12	ICAX1,x		//Read and write
    11 269F A9 00 9D 4B 03		mva #0 ICAX2,x
    12 26A4 20 56 E4			jsr CIOV
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   663 26A7				open 1,4,0,LOC_K
Macro: OPEN [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm]
     7 26A7 A2 10			ldx #(1*16)
     8 26A9 A9 03 9D 42 03		mva #$03 ICCMD,x	//Open
     9 26AE A9 8D 9D 44 03 A9 + 	mwa #LOC_K	ICBAL,x		//"E:","C:","D:"
    10 26B8 A9 04 9D 4A 03		mva #4	ICAX1,x		//Read and write
    11 26BD A9 00 9D 4B 03		mva #0 ICAX2,x
    12 26C2 20 56 E4			jsr CIOV
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace2\GitHub\ARDungeonCartridge\Updater\ArDungeonUpdateV2.asm
   664 26C5 A9 BB 8D 30 02 A9 + 	mwa #dl SDLSTL
   665 26CF A9 00 8D 49 24		mva #$00 flag_busy	//just a flag
   666 26D4 A9 00 8D C6 02		mva #$00 color2
   667 26D9 A9 0F 8D C5 02		mva #$0f color1
   668 26DE A2 26			ldx #>vbi
   669 26E0 A0 36			ldy #<vbi
   670 26E2 A9 06			lda #VBI_I
   671 26E4 20 5C E4			jsr setvbv			//Set VBI to prevent cartridge lockup
   672 26E7 A2 26			ldx #>vbd
   673 26E9 A0 47			ldy #<vbd
   674 26EB A9 07			lda #VBI_D
   675 26ED 20 5C E4			jsr setvbv			//VBD to look on consol keys.
   676
   677 26F0			loop_start
   678 26F0 AD 4B 24			lda flag_start
   679 26F3 F0 FB			beq loop_start
   680 					
   681 				//Start main process
   682 26F5 A9 01 8D 49 24		mva #$01 flag_busy	//Put it as busy
   683 26FA A9 00 8D 4E 24		mva #starting_bank banknum
   684 26FF A9 10 8D 50 24 A9 + 	mwa #init_rom_sector sector
   685 2709 CE 4B 24			dec flag_start	
   686 270C 20 89 24			jsr put_final_bank
   687
   688 				// 1st step: Erase cartridge
   689 270F			First_step
   690 270F 20 AE 24			jsr put_erase
   691 					
   692 				.if starting_bank =$00
   693 					.if final_bank =$7f
   694 						jsr Erase_Cartridge
   695 					.else
   696 2712 20 40 25				jsr Erase_patch
   697 					.endif
   698 				.else
   699 					jsr Erase_patch
   700 				.endif
   701
   702
   703 				// 2nd step: Verify erase
   704 2715 20 BC 24			jsr put_veryfing
   705 2718 20 48 25			jsr Verify_Erase
   706 271B B0 F2			bcs First_step
   707 					
   708
   709 271D A9 50 8D 4F 24		mva #total_banks count
   710 2722			loop
   711 2722 20 62 24			jsr put_banknum
   712
   713 2725 20 CA 24			jsr put_reading
   714 2728 20 50 25			jsr Read_bank
   715
   716 272B			error_write	
   717 272B 20 D8 24			jsr put_writing
   718 272E 20 A8 25			jsr Write_bank
   719
   720 2731 20 E6 24			jsr put_verify_write
   721 2734 20 DB 25			jsr Verify_bank
   722 2737 B0 F2			bcs error_write
   723 					
   724 2739 EE 4E 24			inc banknum
   725 273C CE 4F 24			dec count
   726 273F D0 E1			bne loop	
   727 					
   728 					
   729 2741 20 F4 24			jsr put_done
   730 2744 A9 00			lda #$00
   731 2746 8D 49 24			sta flag_busy
   732 2749 4C F0 26			jmp loop_start
   733 					
   734 274C			end_program	
   735 					
   736 = 074D			total_program	= end_program-start_data+1
   737 = 07CC			total_temp		= total_program + 127
   738 = 000F			total sectors	= total_temp/128
   739 = 0780			total_bytes		= ((Total_Program+127)/128)*128
   740 = 0034			filler			= total_bytes - total_program +1
   741
   742 				.if filler > 0
   743 274C 00 00 00 00 00 00 + 	.sav filler
   744 				.endif
   745
   746 					
   747 2780			start_rom
   748
   749 2780 A9 FF 8D 01 D3 A9 + 	ins "../BOOTCartridge/Alternate Reality - The dungeon/Ardungeon.rom",starting_bank*$2000,total_banks*$2000
   750
   751 0A2780			end_rom
   752
   753 0A2780			end_atr
   754 					
   755 					
   756 				//	run start
   757 						
