mads 2.0.6 build 58 (28 Jan 17)
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\ArdungeonV4.asm
     1 				// ****************************************************
     2 				// *                                                  *
     3 				// * Generic BOOT Cartridge routine                   *
     4 				// *                                                  *
     5 				// *     (C) Guillermo Fuenzalida (Willysoft)         *
     6 				// *                                                  *
     7 				// ****************************************************
     8
     9
    10
    11
    12 				// First, we will define the extension as .rom
    13
    14 				;	@com.wudsn.ide.asm.outputfileextension=.rom
    15
    16 				// Now we set no binary headers
    17
    18 					opt h-
    19
    20 				; include files, useful macros:
    21 					icl "../../base/sys_equates.m65"
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_equates.m65
     1 				;================================================================================
     2 				; System equates, Atari XL + mads [NRV 2009]
     3 				;================================================================================
     4
     5 				;----------------------------------------
     6 				; GTIA:
     7 				;----------------------------------------
     8
     9 = D000			M0PF	= $D000  ; read only
    10 = D001			M1PF	= $D001  ; read only
    11 = D002			M2PF	= $D002  ; read only
    12 = D003			M3PF	= $D003  ; read only
    13
    14 = D004			P0PF	= $D004  ; read only
    15 = D005			P1PF	= $D005  ; read only
    16 = D006			P2PF	= $D006  ; read only
    17 = D007			P3PF	= $D007  ; read only
    18
    19 = D008			M0PL	= $D008  ; read only
    20 = D009			M1PL	= $D009  ; read only
    21 = D00A			M2PL	= $D00A  ; read only
    22 = D00B			M3PL	= $D00B  ; read only
    23
    24 = D00C			P0PL	= $D00C  ; read only
    25 = D00D			P1PL	= $D00D  ; read only
    26 = D00E			P2PL	= $D00E  ; read only
    27 = D00F			P3PL	= $D00F  ; read only
    28
    29 = D010			TRIG0	= $D010  ; read only
    30 = D011			TRIG1	= $D011  ; read only
    31 = D012			TRIG2	= $D012  ; read only
    32 = D013			TRIG3	= $D013  ; read only
    33
    34 = D014			PAL		= $D014  ; read only
    35
    36 				; positions for normal screen: 48 left (+160)--> 208 right (or 32-->224 for wide playfield)
    37 				; 32 top (+192)--> 224 bottom (or 16-->112 for double line resolution)
    38 = D000			HPOSP0	= $D000  ; write only
    39 = D001			HPOSP1	= $D001  ; write only
    40 = D002			HPOSP2	= $D002  ; write only
    41 = D003			HPOSP3	= $D003  ; write only
    42
    43 = D004			HPOSM0	= $D004  ; write only
    44 = D005			HPOSM1	= $D005  ; write only
    45 = D006			HPOSM2	= $D006  ; write only
    46 = D007			HPOSM3	= $D007  ; write only
    47
    48 				; 0 (or 2) normal width, 1 double width, 4 quadruple width
    49 = D008			SIZEP0	= $D008  ; write only
    50 = D009			SIZEP1	= $D009  ; write only
    51 = D00A			SIZEP2	= $D00A  ; write only
    52 = D00B			SIZEP3	= $D00B  ; write only
    53
    54 = D00C			SIZEM	= $D00C  ; write only		// the same 2 bits as the players, but in one byte, in this order: m3m2m1m0
    55
    56 = D00D			GRAFP0	= $D00D  ; write only
    57 = D00E			GRAFP1	= $D00E  ; write only
    58 = D00F			GRAFP2	= $D00F  ; write only
    59 = D010			GRAFP3	= $D010  ; write only
    60
    61 = D011			GRAFM	= $D011  ; write only		// 4 missiles in this order: m3m2m1m0
    62
    63 = D012			COLPM0	= $D012  ; write only
    64 = D013			COLPM1	= $D013  ; write only
    65 = D014			COLPM2	= $D014  ; write only
    66 = D015			COLPM3	= $D015  ; write only
    67
    68 = D016			COLPF0	= $D016  ; write only
    69 = D017			COLPF1	= $D017  ; write only
    70 = D018			COLPF2	= $D018  ; write only
    71 = D019			COLPF3	= $D019  ; write only
    72
    73 = D01A			COLBK	= $D01A  ; write only
    74
    75 = D01B			PRIOR	= $D01B  ; write only
    76 = D01C			VDELAY	= $D01C  ; write only
    77 = D01D			GRACTL	= $D01D  ; write only
    78 = D01E			HITCLR	= $D01E  ; write only
    79
    80 = D01F			CONSOL	= $D01F  ; read and write
    81
    82 				;----------------------------------------
    83 				; POKEY:
    84 				;----------------------------------------
    85
    86 = D200			POT0	= $D200  ; read only
    87 = D201			POT1	= $D201  ; read only
    88 = D202			POT2	= $D202  ; read only
    89 = D203			POT3	= $D203  ; read only
    90 = D204			POT4	= $D204  ; read only
    91 = D205			POT5	= $D205  ; read only
    92 = D206			POT6	= $D206  ; read only
    93 = D207			POT7	= $D207  ; read only
    94
    95 = D208			ALLPOT	= $D208  ; read only
    96
    97 = D209			KBCODE	= $D209  ; read only
    98 = D20A			RANDOM	= $D20A  ; read only
    99
   100 = D20D			SERIN	= $D20D  ; read only
   101 = D20E			IRQST	= $D20E  ; read only
   102 = D20F			SKSTAT	= $D20F  ; read only
   103
   104
   105 = D200			AUDF1	= $D200  ; write only
   106 = D201			AUDC1	= $D201  ; write only
   107 = D202			AUDF2	= $D202  ; write only
   108 = D203			AUDC2	= $D203  ; write only
   109 = D204			AUDF3	= $D204  ; write only
   110 = D205			AUDC3	= $D205  ; write only
   111 = D206			AUDF4	= $D206  ; write only
   112 = D207			AUDC4	= $D207  ; write only
   113
   114 = D208			AUDCTL	= $D208  ; write only
   115
   116 = D209			STIMER	= $D209  ; write only
   117 = D20A			SKREST	= $D20A  ; write only
   118 = D20B			POTGO	= $D20B  ; write only
   119
   120 = D20D			SEROUT	= $D20D  ; write only
   121 = D20E			IRQEN	= $D20E  ; write only
   122 = D20F			SKCTL	= $D20F  ; write only
   123
   124 				;----------------------------------------
   125 				; PIA:
   126 				;----------------------------------------
   127
   128 = D300			PORTA	= $D300  ; read and write
   129 = D301			PORTB	= $D301  ; read and write
   130 = D302			PACTL	= $D302  ; read and write
   131 = D303			PBCTL	= $D303  ; read and write
   132
   133 				;----------------------------------------
   134 				; ANTIC:
   135 				;----------------------------------------
   136
   137 = D40B			VCOUNT	= $D40B  ; read only
   138
   139 = D40C			PENH	= $D40C  ; read only
   140 = D40D			PENV	= $D40D  ; read only
   141
   142 = D40F			NMIST	= $D40F  ; read only
   143
   144
   145 = D400			DMACTL	= $D400  ; write only
   146 = D401			CHACTL	= $D401  ; write only
   147 = D402			DLISTL	= $D402  ; write only
   148 = D403			DLISTH	= $D403  ; write only
   149 = D404			HSCROL	= $D404  ; write only
   150 = D405			VSCROL	= $D405  ; write only
   151 = D407			PMBASE	= $D407  ; write only
   152 = D409			CHBASE	= $D409  ; write only
   153 = D40A			WSYNC	= $D40A  ; write only
   154 = D40E			NMIEN	= $D40E  ; write only
   155 = D40F			NMIRES	= $D40F  ; write only
   156
   157 				;----------------------------------------
   158 				; Shadow registers:
   159 				;----------------------------------------
   160
   161 = 0218			CDTMV1	= $218
   162 = 021A			CDTMV2	= $21a
   163 = 021C			CDTMV3	= $21c
   164 = 021E			CDTMV4	= $21e
   165 = 0220			CDTMV5	= $220
   166
   167
   168 = 022F			SDMCTL	= $22f	; shadow of DMACTL
   169 = 026F			GPRIOR	= $26f	; shadow of PRIOR
   170
   171 = 02C0			PCOLR0	= $2c0	; shadow of COLPM0
   172 = 02C1			PCOLR1  = $2c1
   173 = 02C2			PCOLR2  = $2c2
   174 = 02C3			PCOLR3  = $2c3
   175 = 02C4			COLOR0	= $2c4	; shadow of COLPF0
   176 = 02C5			COLOR1  = $2c5
   177 = 02C6			COLOR2  = $2c6
   178 = 02C7			COLOR3  = $2c7
   179 = 02C8			COLOR4  = $2c8
   180
   181 = 02E0			RUNAD	= $2e0
   182 = 02E2			INITAD	= $2e2
   183
   184 = 0014			RTCLOCK	= $14
   185 = 0041			SOUNDR	= $41
   186 = 0042			CRITIC	= $42
   187 = 004D			ATRACT	= 77
   188
   189 = 0052			LMARGN = $52
   190 = 0053			RMARGN = $53
   191 = 0062			PALNTS = $62
   192 = 006A			RAMTOP = $6A
   193
   194 = 02F4			CHBAS	= $2F4	; shadow of CHBASE
   195 = 02FC			CH	= $2FC
   196 = 02F3			CHACT	= $2F3  ; 
   197
   198 = 0340			ICHID = $340
   199 = 0341			ICDNO = $341
   200 = 0342			ICCMD = $342
   201 = 0343			ICSTA = $343
   202 = 0344			ICBAL = $344
   203 = 0345			ICBAH = $345
   204 = 0346			ICPTL = $346
   205 = 0347			ICPTH = $347
   206 = 0348			ICBLL = $348
   207 = 0349			ICBLH = $349
   208 = 034A			ICAX1 = $34A
   209 = 034B			ICAX2 = $34B
   210
   211 = 03F8			BASICF  = $3f8
   212 = 03FA			GINTLK  = $3fa
   213
   214
   215 = 0230			SDLSTL	= $230	; display list address
   216 = 0200			VDSLST	= $200	; DLI address
   217
   218 = 0301			DUNIT	= $301
   219 = 0302			DCOMND	= $302
   220 = 0303			DSTATS	= $303
   221 = 0304			DBUFLO	= $304
   222 = 0305			DBUFHI	= $305
   223
   224 = 030A			DAUX1	= $30A
   225 = 030B			DAUX2	= $30B
   226
   227
   228 = 0270			PADDL0	= 624	; 0-228 , shadow of POT0
   229 = 027C			PTRIG0	= 636	; 0 = PRESSED , shadow of PTRG0
   230 = 0278			STICK0	= 632	; 0000 = RLDU , shadow of PORTA
   231 = 0284			STRIG0	= 644	; 0 = PRESSED , shadow of TRIG0
   232
   233 = 0244			COLDST	= $244	; non zero --> do a cold start when pressing the reset key
   234
   235 				;----------------------------------------
   236 				; VBI:
   237 				;----------------------------------------
   238
   239 = E45C			SETVBV			= $E45C
   240 = E45F			XITVB_I			= $E45F
   241 = E45F			SYSVBV			= $E45F
   242 = E462			XITVB_D			= $E462
   243 = E462			XITVBV			= $E462
   244 = 0006			VBI_I			= 6
   245 = 0007			VBI_D			= 7
   246 = C0E2			NORMAL_VBI_I	= 49378
   247 = C28A			NORMAL_VBI_D	= 49802
   248 = 0222			VVBLKI			= 546
   249 = 0224			VVBLKD			= 548
   250 = E462			XITVB			= XITVB_D
   251
   252 				;----------------------------------------
   253 				; Handler vectors:
   254 				;----------------------------------------
   255
   256 = FFFA			NMIH_VECTOR		= 65530
   257 = FFFC			RESH_VECTOR		= 65532
   258 = FFFE			IRQH_VECTOR		= 65534
   259
   260 				;----------------------------------------
   261 				; I/O:
   262 				;----------------------------------------
   263
   264 = E456			CIOV			= $E456	; (58454)
   265 = E459			SIOV			= $E459	; (58457)
   266
   267 				;----------------------------------------
   268 				; Restart routines
   269 				;----------------------------------------
   270
   271 = E474			WARMSV			= $E474
   272 = E477			COLDSV			= $E477
   273
   274 				;----------------------------------------
   275 				; Bit values:
   276 				;----------------------------------------
   277
   278 				; DMA values
   279 = 0020			DV_DMA_ON			= %00100000
   280 = 0010			DV_PM_ONE_LINE		= %00010000
   281 = 0008			DV_PLAYERS_ON		= %00001000
   282 = 0004			DV_MISSILES_ON		= %00000100
   283 = 0003			DV_WIDE_PF			= %00000011
   284 = 0002			DV_NORMAL_PF		= %00000010
   285 = 0001			DV_NARROW_PF		= %00000001
   286
   287 				; Display list values
   288 = 0080			DL_DLI_MASK		= %10000000
   289 = 0040			DL_LMS_MASK		= %01000000
   290 = 0020			DL_VSCROLL_MASK	= %00100000
   291 = 0010			DL_HSCROLL_MASK	= %00010000
   292
   293 = 0001			DL_JMP		= 1
   294 = 0041			DL_JVB		= 65
   295
   296 = 0000			DL_BLANK_1	= 0
   297 = 0010			DL_BLANK_2	= 16
   298 = 0020			DL_BLANK_3	= 32
   299 = 0030			DL_BLANK_4	= 48
   300 = 0040			DL_BLANK_5	= 64
   301 = 0050			DL_BLANK_6	= 80
   302 = 0060			DL_BLANK_7	= 96
   303 = 0070			DL_BLANK_8	= 112
   304
   305 				; Antic graphic modes
   306 = 0002			GM_CHAR_A2	= 2			; 2 colors, 40x24, 960b, 40xline, 8 scanlines
   307 = 0006			GM_CHAR_A6	= 6			; 4 colors, 20x24, 480b, 40xline, 8 scanlines
   308 = 0007			GM_CHAR_A7	= 7			; 4 colors, 20x12, 240b, 20xline, 16 scanlines
   309 = 0004			GM_CHAR_A4	= 4			; 5 colors, 40x24, 960b, 40xline, 8 scanlines
   310 = 0005			GM_CHAR_A5	= 5			; 5 colors, 40x12, 480b, 40xline, 16 scanlines
   311 = 0003			GM_CHAR_A3	= 3			; 2 colors, 40x24, 760b, 40xline, 10 scanlines
   312
   313 				; Basic graphic modes
   314 = 0002			GM_CHAR_G0	= 2			; 2 colors, 40x24, 960b, 40xline, 8 scanlines
   315 = 0006			GM_CHAR_G1	= 6			; 4 colors, 20x24, 480b, 40xline, 8 scanlines
   316 = 0007			GM_CHAR_G2	= 7			; 4 colors, 20x12, 240b, 20xline, 16 scanlines
   317 = 0004			GM_CHAR_G12	= 4			; 5 colors, 40x24, 960b, 40xline, 8 scanlines
   318 = 0005			GM_CHAR_G13	= 5			; 5 colors, 40x12, 480b, 40xline, 16 scanlines
   319
   320 = 0008			GM_PIXEL_G3	= 8			; 4 colors, 40x24, 240b, 10xline, 8 scanline
   321 = 0009			GM_PIXEL_G4	= 9			; 2 colors, 80x48, 480b, 10xline, 4 scanline
   322 = 000A			GM_PIXEL_G5	= 10		; 4 colors, 80x48, 960b, 20xline, 4 scanline
   323 = 000B			GM_PIXEL_G6	= 11		; 2 colors, 160x96, 1920b, 20xline, 2 scanline
   324 = 000D			GM_PIXEL_G7	= 13		; 4 colors, 160x96, 3840b, 40xline, 2 scanline
   325 = 000F			GM_PIXEL_G8	= 15		; 2 colors, 320x192, 7680b, 40xline, 1 scanline
   326 = 000C			GM_PIXEL_G14	= 12	; 2 colors, 160x192, 3840b, 20xline, 1 scanline
   327 = 000E			GM_PIXEL_G15	= 14	; 4 colors, 160x192, 7680b, 40xline, 1 scanline
   328
   329 = 000F			GM_PIXEL_G9	= 15		; 1 color, 80x192, 7680b, 40xline, 1 scanline
   330 = 000F			GM_PIXEL_G10	= 15	; 9 colors, 80x192, 7680b, 40xline, 1 scanline
   331 = 000F			GM_PIXEL_G11	= 15	; 16 colors, 80x192, 7680b, 40xline, 1 scanline
   332
   333 				; Prior values
   334 = 0001			PRV_PM_PRIORITY_1	= %00000001		; p0 p1 p2 p3 / pf0 pf1 pf2 pf3 (p5) / bk
   335 = 0002			PRV_PM_PRIORITY_2	= %00000010		; p0 p1 / pf0 pf1 pf2 pf3 (p5) / p2 p3 / bk
   336 = 0004			PRV_PM_PRIORITY_3	= %00000100		; pf0 pf1 pf2 pf3 (p5) /  p0 p1 p2 p3 / bk
   337 = 0008			PRV_PM_PRIORITY_4	= %00001000		; pf1 pf2 /  p0 p1 p2 p3 / pf0 pf3 (p5) / bk
   338 = 0010			PRV_FIFTH_PLAYER	= %00010000
   339 = 0020			PRV_PM_OVERLAP		= %00100000
   340 = 0040			PRV_GTIA_9			= %01000000
   341 = 0080			PRV_GTIA_10			= %10000000
   342 = 00C0			PRV_GTIA_11			= %11000000
   343
   344 				; Gractl values
   345 = 0001			GCTL_MISSILES		= %001
   346 = 0002			GCTL_PLAYERS		= %010
   347 = 0004			GCTL_LATCH_TRIGGERS	= %100
   348
   349 				; Consol values:
   350 = 0001			CNV_START_MASK		= %001
   351 = 0002			CNV_OPTION_MASK		= %010
   352 = 0004			CNV_SELECT_MASK		= %100
   353
   354 				; Stick values:
   355 = 0008			STV_RIGHT_MASK		= %1000
   356 = 0004			STV_LEFT_MASK		= %0100
   357 = 0002			STV_DOWN_MASK		= %0010
   358 = 0001			STV_UP_MASK			= %0001
   359
   360 = 0008			STICK_MASK_RIGHT	= %1000
   361 = 0004			STICK_MASK_LEFT		= %0100
   362 = 0002			STICK_MASK_DOWN		= %0010
   363 = 0001			STICK_MASK_UP		= %0001
   364
   365 = 0007			STICK_VALUE_RIGHT	= %0111
   366 = 000B			STICK_VALUE_LEFT	= %1011
   367 = 000D			STICK_VALUE_DOWN	= %1101
   368 = 000E			STICK_VALUE_UP		= %1110
   369
   370 				/*
   371 				KBCode Hexadecimal Values
   372 				 	$00	$01	$02	$03	$04	$05	$06	$07	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
   373 				$00	L	J	;	F1	F2	K	+	*	O	 	P	U	CR	I	-	=
   374 				$10	V	Hlp	C	F3	F4	B	X	Z	4	 	3	6	Esc	5	2	1
   375 				$20	,	Spc	.	N	 	M	/	Inv	R	 	E	Y	Tab	T	W	Q
   376 				$30	9	 	0	7	BS	8	<	>	F	H	D	 	Cap	G	S	A
   377
   378 				together with Shift Key: add +$40
   379 				together with Control key: add +$80 
   380 				*/
   380
    22 					icl "../../base/sys_macros.m65"
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65
     1 				;================================================================================
     2 				; System macros, Atari XL + mads [NRV 2009]
     3 				;================================================================================
     4
     5 				;--------------------------------------------------------------------------------
     6 				; SetVector [address] [word]
     7 				;--------------------------------------------------------------------------------
     8
     9 					.macro SetVector
    10 					   .if :0 <> 2
    11 					      .error "SetVector error"
    12 				
    13 					   .else
    14 					      lda #<:2
    15 					      sta :1
    16 					      lda #>:2
    17 					      sta :1+1
    18 					   .endif
    19 				
    20 					.endm
    21
    22
    23 				;--------------------------------------------------------------------------------
    24 				; SetColor [0..4] [0..255]
    25 				; SetColor [0..4] [0..15] [0..15]
    26 				;--------------------------------------------------------------------------------
    27
    28 					.macro SetColor
    29 					   .if :0 < 2 .or :0 > 3
    30 					      .error "SetColor error"
    31 				
    32 					   .else
    33 					      .if :0 = 2
    34 					          lda #:2
    35 					          sta COLPF0+:1
    36 					      .else
    37 					          lda #[:2 * 16 + :3]
    38 					          sta COLPF0+:1
    39 					      .endif
    40 					   .endif
    41 				
    42 					.endm
    43
    44
    45 				;--------------------------------------------------------------------------------
    46 				; SetPMColor [0..3] [0..255]
    47 				; SetPMColor [0..3] [0..15] [0..15]
    48 				;--------------------------------------------------------------------------------
    49
    50 					.macro SetPMColor
    51 					   .if :0 < 2 .or :0 > 3
    52 					      .error "SetPMColor error"
    53 				
    54 					   .else
    55 					      .if :0 = 2
    56 					          lda #:2
    57 					          sta COLPM0+:1
    58 					      .else
    59 					          lda #[:2 * 16 + :3]
    60 					          sta COLPM0+:1
    61 					      .endif
    62 					   .endif
    63 				
    64 					.endm
    65
    66
    67 				;--------------------------------------------------------------------------------
    68 				; VcountSync [0..130]
    69 				; (maximum limit is different on PAL: 155)
    70 				; (could wait forever if there are interrupts activated!)
    71 				; (or if some other "thread" uses "wsync")
    72 				;--------------------------------------------------------------------------------
    73
    74 					.macro VcountSync
    75 					   .if :0 <> 1
    76 					      .error "VcountSync error"
    77 				
    78 					   .else
    79 					      sta WSYNC
    80 				
    81 					      lda #:1
    82 				VSync1	 cmp VCOUNT
    83 					      bne VSync1
    84 				
    85 					      lda #:1+1
    86 				VSync2	 cmp VCOUNT
    87 					      bne VSync2
    88 				
    89 					      sta WSYNC
    90 					   .endif
    91 				
    92 					.endm
    93
    94
    95 				;--------------------------------------------------------------------------------
    96 				; VcountWait [0..130]
    97 				; (maximum limit is different on PAL: 155)
    98 				;--------------------------------------------------------------------------------
    99
   100 					.macro VcountWait
   101 					   .if :0 <> 1
   102 					      .error "VcountWait error"
   103 				
   104 					   .else
   105 					      lda #:1
   106 				VWait1	 cmp VCOUNT
   107 					      bne VWait1
   108 					   .endif
   109 				
   110 					.endm
   111
   112
   113 				;--------------------------------------------------------------------------------
   114 				; VcountWaitUntilEnter [0..129] [(p1+1)..130]
   115 				; (maximum limit is different on PAL: 155)
   116 				;--------------------------------------------------------------------------------
   117
   118 					.macro VcountWaitUntilEnter
   119 					   .if :0 <> 2 .or :1 >= :2
   120 					      .error "VcountWaitUntilEnter error"
   121 				
   122 					   .else
   123 				VWait1     lda VCOUNT
   124 						 cmp #:1
   125 						 beq VExit
   126 					      bcc VWait1	; VCOUNT < :1
   127 						 cmp #:2
   128 						 beq VExit
   129 					      bcs VWait1	; VCOUNT >= :2
   130 				VExit
   131 					   .endif
   132 				
   133 					.endm
   134
   135
   136 				;--------------------------------------------------------------------------------
   137 				; VcountWaitUntilExit [0..129] [(p1+1)..130]
   138 				; (maximum limit is different on PAL: 155)
   139 				;--------------------------------------------------------------------------------
   140
   141 					.macro VcountWaitUntilExit
   142 					   .if :0 <> 2 .or :1 >= :2
   143 					      .error "VcountWaitUntilExit error"
   144 				
   145 					   .else
   146 				VWait1     lda VCOUNT
   147 						 cmp #:1
   148 						 beq VWait1
   149 					      bcc VExit	; VCOUNT < :1
   150 						 cmp #:2
   151 					      bcc VWait1	; VCOUNT < :2
   152 						 beq VWait1
   153 				VExit
   154 					   .endif
   155 				
   156 					.endm
   157
   158
   159 				;--------------------------------------------------------------------------------
   160 				; MarkScanLine [0..255] [0..255]
   161 				; (mark the current scan line with a color)
   162 				;--------------------------------------------------------------------------------
   163
   164 					.macro MarkScanLine
   165 					   .if :0 <> 0 .and :0 <> 2
   166 					      .error "MarkScanLine error"
   167 				
   168 					   .else
   169 					  	   .if :0 = 0
   170 				  		      sta WSYNC
   171 				  	     	 lda #255		; mark color
   172 					  	      sta COLBK
   173 				
   174 				  		      sta WSYNC
   175 				  	     	 lda #0		; restore color
   176 					  	      sta COLBK
   177 				
   178 				  		   .else
   179 					     	 sta WSYNC
   180 						      lda #:1		; mark color
   181 						      sta COLBK
   182 				
   183 						      sta WSYNC
   184 						      lda #:2		; restore color
   185 					     	 sta COLBK
   186 						   .endif
   187 					   .endif
   188 				
   189 					.endm
   190
   191
   192 				;--------------------------------------------------------------------------------
   193 				; MarkScanLineIfConsol [0..255] [0..255]
   194 				; (mark the current scan line with a color, if a consol key is pressed)
   195 				;--------------------------------------------------------------------------------
   196
   197 					.macro MarkScanLineIfConsol
   198 					   .if :0 <> 0 .and :0 <> 2
   199 					      .error "MarkScanLineIfConsol error"
   200 				
   201 					   .else
   202 						 .if :0 = 0
   203 						      lda CONSOL
   204 						      and #%111
   205 					     	 cmp #%111
   206 						      beq ExitMarkScanLineIfConsol
   207 				
   208 						      sta WSYNC
   209 						      lda #255		; mark color
   210 						      sta COLBK
   211 				
   212 						      sta WSYNC
   213 						      lda #0		; restore color
   214 					     	 sta COLBK
   215 				
   216 					   	 .else
   217 						      lda CONSOL
   218 						      and #%111
   219 					     	 cmp #%111
   220 						      beq ExitMarkScanLineIfConsol
   221 				
   222 						      sta WSYNC
   223 					     	 lda #:1		; mark color
   224 						      sta COLBK
   225 				
   226 						      sta WSYNC
   227 					     	 lda #:2		; restore color
   228 						      sta COLBK
   229 				
   230 					   	 .endif
   231 					   .endif
   232 				
   233 				ExitMarkScanLineIfConsol
   234 				
   235 					.endm
   236
   237
   238 				;--------------------------------------------------------------------------------
   239 				; MarkCyclesIfConsol [0..255] [0..255]
   240 				; (mark the current scan position with a color, for some cycles)
   241 				;--------------------------------------------------------------------------------
   242
   243 					.macro MarkCyclesIfConsol
   244 					   .if :0 = 0
   245 					      lda CONSOL
   246 					      and #%111
   247 					      cmp #%111
   248 					      beq ExitMarkCyclesIfConsol
   249 				
   250 					      lda #255		; mark color
   251 					      sta COLBK
   252 				
   253 					      lda ($00),y	; dummy 5 cycles
   254 					      lda ($00),y	; dummy 5 cycles
   255 					      lda ($00),y	; dummy 5 cycles
   256 					      lda ($00),y	; dummy 5 cycles
   257 					      lda ($00),y	; dummy 5 cycles
   258 					      lda ($00),y	; dummy 5 cycles
   259 				
   260 					      lda #0		; restore color
   261 					      sta COLBK
   262 				
   263 					   .elseif :0 = 2
   264 					      lda CONSOL
   265 					      and #%111
   266 					      cmp #%111
   267 					      beq ExitMarkCyclesIfConsol
   268 				
   269 					      lda #:1		; mark color
   270 					      sta COLBK
   271 				
   272 					      lda ($00),y	; dummy 5 cycles
   273 					      lda ($00),y	; dummy 5 cycles
   274 					      lda ($00),y	; dummy 5 cycles
   275 					      lda ($00),y	; dummy 5 cycles
   276 					      lda ($00),y	; dummy 5 cycles
   277 					      lda ($00),y	; dummy 5 cycles
   278 				
   279 					      lda #:2		; restore color
   280 					      sta COLBK
   281 				
   282 					   .else
   283 					      .error "MarkCyclesIfConsol error"
   284 				
   285 					   .endif
   286 				
   287 				ExitMarkCyclesIfConsol
   288 				
   289 					.endm
   290
   291
   292 				;--------------------------------------------------------------------------------
   293 				; SetBasic [0,1]
   294 				;--------------------------------------------------------------------------------
   295
   296 					.macro SetBasic
   297 					   .if :0 <> 1
   298 					      .error "SetBasic error"
   299 				
   300 					   .else
   301 					      .if :1 = 0
   302 					         lda PORTB	; deactivate Basic
   303 					         ora #%00000010
   304 					         sta PORTB
   305 					      .else
   306 					         lda PORTB	; activate Basic
   307 					         and #%11111101
   308 					         sta PORTB
   309 					      .endif
   310 					   .endif
   311 				
   312 					.endm
   313
   314
   315 				;--------------------------------------------------------------------------------
   316 				; SetOperativeSystem [0,1]
   317 				;--------------------------------------------------------------------------------
   318
   319 					.macro SetOperativeSystem
   320 					   .if :0 <> 1
   321 					      .error "SetOperativeSystem error"
   322 				
   323 					   .else
   324 					      .if :1 = 0
   325 					         lda PORTB	; deactivate Operative System
   326 					         and #%11111110
   327 					         sta PORTB
   328 					      .else
   329 					         lda PORTB	; activate Operative System
   330 					         ora #%00000001
   331 					         sta PORTB
   332 					      .endif
   333 					   .endif
   334 				
   335 					.endm
   336
   337
   338 				;--------------------------------------------------------------------------------
   339 				; EnableBasic
   340 				;--------------------------------------------------------------------------------
   341
   342 					.macro EnableBasic
   343 					   .if :0 <> 0
   344 					      .error "EnableBasic error"
   345 				
   346 					   .else
   347 					      SetBasic 1
   348 					   .endif
   349 				
   350 					.endm
   351
   352
   353 				;--------------------------------------------------------------------------------
   354 				; DisableBasic
   355 				;--------------------------------------------------------------------------------
   356
   357 					.macro DisableBasic
   358 					   .if :0 <> 0
   359 					      .error "DisableBasic error"
   360 				
   361 					   .else
   362 					      SetBasic 0
   363 					   .endif
   364 				
   365 					.endm
   366
   367
   368 				;--------------------------------------------------------------------------------
   369 				; EnableOperativeSystem
   370 				;--------------------------------------------------------------------------------
   371
   372 					.macro EnableOperativeSystem
   373 					   .if :0 <> 0
   374 					      .error "EnableOperativeSystem error"
   375 				
   376 					   .else
   377 					      SetOperativeSystem 1
   378 					   .endif
   379 				
   380 					.endm
   381
   382
   383 				;--------------------------------------------------------------------------------
   384 				; DisableOperativeSystem
   385 				;--------------------------------------------------------------------------------
   386
   387 					.macro DisableOperativeSystem
   388 					   .if :0 <> 0
   389 					      .error "DisableOperativeSystem error"
   390 				
   391 					   .else
   392 					      SetOperativeSystem 0
   393 					   .endif
   394 				
   395 					.endm
   396
   397
   398 				;--------------------------------------------------------------------------------
   399 				; EnableNormalInterrupts
   400 				;--------------------------------------------------------------------------------
   401
   402 					.macro EnableNormalInterrupts
   403 					   .if :0 <> 0
   404 					      .error "EnableNormalInterrupts error"
   405 				
   406 					   .else
   407 					      cli
   408 				;	      lda #[8+16+32]	; serial I/O interrupts
   409 				;	      lda #[64+128]		; keyboard and break interrupts (only ones enabled on powerup)
   410 				;	      sta IRQEN
   411 					      lda #64			; VBI interrupt
   412 					      sta NMIEN
   413 					   .endif
   414 				
   415 					.endm
   416
   417
   418 				;--------------------------------------------------------------------------------
   419 				; DisableNormalInterrupts
   420 				;--------------------------------------------------------------------------------
   421
   422 					.macro DisableNormalInterrupts
   423 					   .if :0 <> 0
   424 					      .error "DisableNormalInterrupts error"
   425 				
   426 					   .else
   427 					      sei
   428 					      lda #0
   429 					      sta IRQEN
   430 					      sta NMIEN
   431 					   .endif
   432 				
   433 					.endm
   434
   435
   436 				;--------------------------------------------------------------------------------
   437 				; ClearSystem
   438 				;--------------------------------------------------------------------------------
   439
   440 					.macro ClearSystem
   441 					   .if :0 <> 0
   442 					      .error "ClearSystem error"
   443 				
   444 					   .else
   445 					      clc
   446 					      cld
   447 				
   448 					      sei
   449 				
   450 					      lda #0
   451 					      sta IRQEN	; clear interrupts and screen
   452 					      sta NMIEN
   453 				
   454 					      sta DMACTL
   455 					      sta COLBK
   456 				
   457 					      sta GRACTL	; clear P/M
   458 					      sta GRAFP0
   459 					      sta GRAFP1
   460 					      sta GRAFP2
   461 					      sta GRAFP3
   462 					      sta GRAFM
   463 				
   464 					      sta HPOSP0
   465 					      sta HPOSP1
   466 					      sta HPOSP2
   467 					      sta HPOSP3
   468 					      sta HPOSM0
   469 					      sta HPOSM1
   470 					      sta HPOSM2
   471 					      sta HPOSM3
   472 				
   473 					      sta PRIOR	; clear GTIA also
   474 				
   475 					      sta AUDCTL	; clear sound
   476 					      sta AUDC1
   477 					      sta AUDC2
   478 					      sta AUDC3
   479 					      sta AUDC4
   480 				
   481 					      lda #3
   482 					      sta SKCTL
   483 					   .endif
   484 				
   485 					.endm
   486
   487
   488 				;--------------------------------------------------------------------------------
   489 				; SetDisplayListAddress [word]
   490 				; (use when the screen is not being displayed!)
   491 				; (remember to not cross the 1K limit..)
   492 				;--------------------------------------------------------------------------------
   493
   494 					.macro SetDisplayListAddress
   495 					   .if :0 <> 1
   496 					      .error "SetDisplayListAddress error"
   497 				
   498 					   .else
   499 					      SetVector DLISTL, :1
   500 				
   501 				;	      lda #<:1
   502 				;	      sta DLISTL
   503 				;	      lda #>:1
   504 				;	      sta DLISTH
   505 					   .endif
   506 				
   507 					.endm
   508
   509
   510 				;--------------------------------------------------------------------------------
   511 				; SetFontAddress [word]
   512 				; (remember that this transform to a page a number)
   513 				;--------------------------------------------------------------------------------
   514
   515 					.macro SetFontAddress
   516 					   .if :0 <> 1
   517 					      .error "SetFontAddress error"
   518 				
   519 					   .else
   520 					      lda #>:1
   521 					      sta CHBASE
   522 					   .endif
   523 				
   524 					.endm
   525
   526
   527 				;--------------------------------------------------------------------------------
   528 				; SetPMBaseAddress [word]
   529 				; (remember that this transform to a page a number)
   530 				;--------------------------------------------------------------------------------
   531
   532 					.macro SetPMBaseAddress
   533 					   .if :0 <> 1
   534 					      .error "SetPMBaseAddress error"
   535 				
   536 					   .else
   537 					      lda #>:1
   538 					      sta PMBASE
   539 					   .endif
   540 				
   541 					.endm
   542
   543
   544 				;--------------------------------------------------------------------------------
   545 				; SetMemory [address] [bytes] [value]
   546 				;--------------------------------------------------------------------------------
   547
   548 				; warning, using some page zero memory
   549
   550 					.macro SetMemory
   551 				
   552 				setMemPtr	= 254
   553 				setMemCounter	= 252
   554 				
   555 					   .if :0 <> 3
   556 					      .error "SetMemory error"
   557 				
   558 					   .else
   559 					      ldy #0
   560 				
   561 					      lda #<:1
   562 					      sta setMemPtr
   563 					      lda #>:1
   564 					      sta setMemPtr+1
   565 				
   566 					      .if :2 < 256
   567 					         lda #:3
   568 				setMemLoop1
   569 					         sta (setMemPtr),y
   570 					         iny
   571 					         cpy #:2
   572 					         bne setMemLoop1
   573 				
   574 					      .else
   575 					         lda #<:2
   576 					         sta setMemCounter
   577 					         lda #>:2
   578 					         sta setMemCounter+1
   579 				
   580 				setMemLoop2
   581 					         lda #:3
   582 					         sta (setMemPtr),y
   583 					         iny
   584 					         bne setMemB1
   585 					         inc setMemPtr+1
   586 				setMemB1
   587 					         lda setMemCounter
   588 					         bne setMemB2
   589 					         dec setMemCounter+1
   590 				setMemB2
   591 					         dec setMemCounter
   592 				
   593 					         lda setMemCounter
   594 					         ora setMemCounter+1
   595 					         bne setMemLoop2
   596 					      .endif
   597 					   .endif
   598 				
   599 					.endm
   600
   601
   602 				;--------------------------------------------------------------------------------
   603 				; SetMemoryRandom [address] [bytes]
   604 				;--------------------------------------------------------------------------------
   605
   606 				; warning, using some page zero memory
   607
   608 					.macro SetMemoryRandom
   609 				
   610 				setMemRPtr	= 254
   611 				setMemRCounter	= 252
   612 				
   613 					   .if :0 <> 2
   614 					      .error "SetMemoryRandom error"
   615 				
   616 					   .else
   617 					      ldy #0
   618 				
   619 					      lda #<:1
   620 					      sta setMemRPtr
   621 					      lda #>:1
   622 					      sta setMemRPtr+1
   623 				
   624 					      .if :2 < 256
   625 				setMemRLoop1
   626 					         lda RANDOM
   627 					         sta (setMemRPtr),y
   628 					         iny
   629 					         cpy #:2
   630 					         bne setMemRLoop1
   631 				
   632 					      .else
   633 					         lda #<:2
   634 					         sta setMemRCounter
   635 					         lda #>:2
   636 					         sta setMemRCounter+1
   637 				
   638 				setMemRLoop2
   639 					         lda RANDOM
   640 					         sta (setMemRPtr),y
   641 					         iny
   642 					         bne setMemRB1
   643 					         inc setMemRPtr+1
   644 				setMemRB1
   645 					         lda setMemRCounter
   646 					         bne setMemRB2
   647 					         dec setMemRCounter+1
   648 				setMemRB2
   649 					         dec setMemRCounter
   650 				
   651 					         lda setMemRCounter
   652 					         ora setMemRCounter+1
   653 					         bne setMemRLoop2
   654 					      .endif
   655 					   .endif
   656 				
   657 					.endm
   658
   659
   660 				;--------------------------------------------------------------------------------
   661 				; ClampMemory [address] [bytes] [min value] [max value]
   662 				;--------------------------------------------------------------------------------
   663
   664 				; warning, using some page zero memory
   665
   666 					.macro ClampMemory
   667 				
   668 				clampMemPtr	= 254
   669 				clampMemCounter	= 252
   670 				
   671 					   .if :0 <> 4
   672 					      .error "ClampMemory error"
   673 				
   674 					   .else
   675 					      ldy #0
   676 				
   677 					      lda #<:1
   678 					      sta clampMemPtr
   679 					      lda #>:1
   680 					      sta clampMemPtr+1
   681 				
   682 					      .if :2 < 256
   683 				clampMemLoop1
   684 					         lda (clampMemPtr),y
   685 					         cmp #:3
   686 					         bcs clampMemB3		; if >= min then continue
   687 					         lda #:3
   688 					         jmp clampMemB4
   689 				clampMemB3
   690 					         cmp #:4
   691 					         bcc clampMemB4		; if < max then continue
   692 				;	         beq clampMemB4		; if = max then continue
   693 					         lda #:4
   694 				clampMemB4
   695 					         sta (clampMemPtr),y
   696 				
   697 					         iny
   698 					         cpy #:2
   699 					         bne clampMemLoop1
   700 				
   701 					      .else
   702 					         lda #<:2
   703 					         sta clampMemCounter
   704 					         lda #>:2
   705 					         sta clampMemCounter+1
   706 				
   707 				clampMemLoop2
   708 					         lda (clampMemPtr),y
   709 					         cmp #:3
   710 					         bcs clampMemB5		; if >= min then continue
   711 					         lda #:3
   712 					         jmp clampMemB6
   713 				clampMemB5
   714 					         cmp #:4
   715 					         bcc clampMemB6		; if < max then continue
   716 				;	         beq clampMemB6		; if = max then continue
   717 					         lda #:4
   718 				clampMemB6
   719 					         sta (clampMemPtr),y
   720 				
   721 					         iny
   722 					         bne clampMemB1
   723 					         inc clampMemPtr+1
   724 				clampMemB1
   725 					         lda clampMemCounter
   726 					         bne clampMemB2
   727 					         dec clampMemCounter+1
   728 				clampMemB2
   729 					         dec clampMemCounter
   730 				
   731 					         lda clampMemCounter
   732 					         ora clampMemCounter+1
   733 					         bne clampMemLoop2
   734 					      .endif
   735 					   .endif
   736 				
   737 					.endm
   738
   739
   740 				;--------------------------------------------------------------------------------
   741 				; AndMemory [address] [bytes] [value]
   742 				;--------------------------------------------------------------------------------
   743
   744 				; warning, using some page zero memory
   745
   746 					.macro AndMemory
   747 				
   748 				andMemPtr	= 254
   749 				andMemCounter	= 252
   750 				
   751 					   .if :0 <> 3
   752 					      .error "AndMemory error"
   753 				
   754 					   .else
   755 					      ldy #0
   756 				
   757 					      lda #<:1
   758 					      sta andMemPtr
   759 					      lda #>:1
   760 					      sta andMemPtr+1
   761 				
   762 					      .if :2 < 256
   763 				andMemLoop1
   764 					         lda (andMemPtr),y
   765 					         and #:3
   766 					         sta (andMemPtr),y
   767 					         iny
   768 					         cpy #:2
   769 					         bne andMemLoop1
   770 				
   771 					      .else
   772 					         lda #<:2
   773 					         sta andMemCounter
   774 					         lda #>:2
   775 					         sta andMemCounter+1
   776 				
   777 				andMemLoop2
   778 					         lda (andMemPtr),y
   779 					         and #:3
   780 					         sta (andMemPtr),y
   781 					         iny
   782 					         bne andMemB1
   783 					         inc andMemPtr+1
   784 				andMemB1
   785 					         lda andMemCounter
   786 					         bne andMemB2
   787 					         dec andMemCounter+1
   788 				andMemB2
   789 					         dec andMemCounter
   790 				
   791 					         lda andMemCounter
   792 					         ora andMemCounter+1
   793 					         bne andMemLoop2
   794 					      .endif
   795 					   .endif
   796 				
   797 					.endm
   798
   799
   800 				;--------------------------------------------------------------------------------
   801 				; CopyMemory [source address] [dest address] [bytes]
   802 				;--------------------------------------------------------------------------------
   803
   804 				; warning, using some page zero memory
   805
   806 					.macro CopyMemory
   807 				
   808 				copyMemPtr1	= 254
   809 				copyMemPtr2	= 252
   810 				copyMemCounter	= 250
   811 				
   812 					   .if :0 <> 3
   813 					      .error "CopyMemory error"
   814 				
   815 					   .else
   816 					      ldy #0
   817 				
   818 					      .if :3 <= 256
   819 				copyMemLoop1
   820 						lda :1,y
   821 						sta :2,y
   822 						iny
   823 						.if :3 < 256
   824 							cpy #<:3
   825 						.endif
   826 						bne copyMemLoop1
   827 				
   828 					      .else
   829 					        lda #<:1
   830 					        sta copyMemPtr1
   831 					        lda #>:1
   832 					        sta copyMemPtr1+1
   833 						lda #<:2
   834 						sta copyMemPtr2
   835 						lda #>:2
   836 						sta copyMemPtr2+1
   837 						lda #<:3
   838 						sta copyMemCounter
   839 						lda #>:3
   840 						sta copyMemCounter+1
   841 				
   842 				copyMemLoop2
   843 						lda (copyMemPtr1),y
   844 						sta (copyMemPtr2),y
   845 						iny
   846 						bne copyMemB1
   847 						inc copyMemPtr1+1
   848 						inc copyMemPtr2+1
   849 				copyMemB1
   850 						lda copyMemCounter
   851 						bne copyMemB2
   852 						dec copyMemCounter+1
   853 				copyMemB2
   854 						dec copyMemCounter
   855 				
   856 						lda copyMemCounter
   857 						ora copyMemCounter+1
   858 						bne copyMemLoop2
   859 					      .endif
   860 					   .endif
   861 				
   862 					.endm
   863
   864
   865 				;--------------------------------------------------------------------------------
   866 				; CreateDisplayList [DL address] [DL mode] [memory address]
   867 				; (remember to not cross the 1K limit.. and the 4K limit)
   868 				;--------------------------------------------------------------------------------
   869
   870 				; 	.macro CreateDisplayList
   871 				; 	   .if :0 <> 3
   872 				; 	      .error "CreateDisplayList error"
   873 				; 
   874 				; 	   .else
   875 				; 
   876 				; 	   .endif
   877 				; 
   878 				; 	.endm
   879
   880
   881 				;--------------------------------------------------------------------------------
   882 				;
   883 				;--------------------------------------------------------------------------------
   884
   885
   886
    23 					
    24 				// Now a cart type definition
    25
    26 				//Cartridge types available
    27 				// 1: Atarimax 8 Mbit
    28 				// 2: Switchable XEGS 8 Mbit
    29 				// 3: Atarimax 1 Mbit
    30 				// 4: Atrax 128 Kbytes (1 Mbit)
    31 				// 5: Megacart 128 KB
    32 				// 6: Megacart 1024 KB
    33
    34 = 0001			TYPE_CART =1
    35
    36 				.if TYPE_CART = 1 
    37 = A000				start_cartridge = $A000
    38 = C000				end_bank = $C000
    39 = 0080				cart_banks = 128
    40 = D5FF				cart_apaga = $D5FF
    41 = 0000				FLAG_16KB = $00
    42 				.elseif TYPE_CART = 2
    43 					start_cartridge = $8000
    44 					end_bank = $A000
    45 					cart_banks = 128
    46 					cart_apaga = $D5FF
    47 					FLAG_16KB = $00
    48 				.elseif TYPE_CART = 3
    49 					start_cartridge = $A000
    50 					end_bank = $C000
    51 					cart_banks = 16
    52 					cart_apaga = $D51F
    53 					FLAG_16KB = $00
    54 				.elseif TYPE_CART = 4
    55 					start_cartridge = $A000
    56 					end_bank = $C000
    57 					cart_banks = 16
    58 					cart_apaga = $D5FF
    59 					FLAG_16KB = $00
    60 				.elseif TYPE_CART = 5
    61 					start_cartridge = $8000
    62 					end_bank = $C000
    63 					cart_banks = 8
    64 					cart_apaga = $D5FF
    65 					FLAG_16KB = $01
    66 				.elseif TYPE_CART = 6
    67 					start_cartridge = $8000
    68 					end_bank = $C000
    69 					cart_banks = 64
    70 					cart_apaga = $D5FF
    71 					FLAG_16KB = $01
    72 				.else
    73 					.error "Cartridge type not defined"
    74 				.endif
    75
    76 				//Parameters to init the loader
    77
    78 = 0400			start_loader = $0400
    79 = CC00			start_loader2 = $cc00		//Dungeon loader.
    80 = CD00			start_cart_io =$cd00		//Cartridge IO routines.
    81 = 0480			start_init2 = $480
    82
    83
    84 				// Page zero parameters
    85 = 0032			BUFRLO 	= $32
    86 = 0033			BUFRHI 	= $33
    87 = 0034			AUX1	= $34
    88 = 0035			AUX2	= $35
    89 = 0036			c_bank	= $36
    90
    91 				//Starting the cartridge
    92
    93 					org start_cartridge
    94 A000				lmb #$00	//BANK 0
    95
    96 				// First, copy the loader routine and get back to the OS. You can do whatever you want to initialize.
    97 				Copy_init
    98 				.proc init
    99 				// 1st stage
   100 A000 A9 FF 8D 01 D3		mva #$ff portb
   101 A005 A9 01 8D F8 03		mva #$01 basicf
   102 A00A				CopyMemory Copy_loader, start_loader,(.len loader)	//Copy loader to the desired address in the parameters.
Macro: COPYMEMORY [Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A00A A0 00			      ldy #0
    13 A00C			copyMemLoop1
    14 A00C B9 29 A2				lda COPY_LOADER,y
    15 A00F 99 00 04				sta START_LOADER,y
    16 A012 C8					iny
    18 A013 C0 6A					cpy #<(.LEN LOADER)
    20 A015 D0 F5				bne copyMemLoop1
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\ArdungeonV4.asm
   103 A017				CopyMemory Copy_init2, init2, (.len init2)		//Copy second init routine if necessary.
Macro: COPYMEMORY [Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A017 A0 00			      ldy #0
    13 A019			copyMemLoop1
    14 A019 B9 36 A1				lda COPY_INIT2,y
    15 A01C 99 80 04				sta INIT2,y
    16 A01F C8					iny
    18 A020 C0 F3					cpy #<(.LEN INIT2)
    20 A022 D0 F5				bne copyMemLoop1
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\ArdungeonV4.asm
   104 A024 78				sei
   105 A025 A9 00 8D 0E D4		mva #$00 nmien
   106 A02A				CopyMemory $c000,$600,$1000				//Copy OS to RAM
Macro: COPYMEMORY [Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A02A A0 00			      ldy #0
    23 A02C A9 00			        lda #<$C000
    24 A02E 85 FE			        sta copyMemPtr1
    25 A030 A9 C0			        lda #>$C000
    26 A032 85 FF			        sta copyMemPtr1+1
    27 A034 A9 00				lda #<$600
    28 A036 85 FC				sta copyMemPtr2
    29 A038 A9 06				lda #>$600
    30 A03A 85 FD				sta copyMemPtr2+1
    31 A03C A9 00				lda #<$1000
    32 A03E 85 FA				sta copyMemCounter
    33 A040 A9 10				lda #>$1000
    34 A042 85 FB				sta copyMemCounter+1
    36 A044			copyMemLoop2
    37 A044 B1 FE				lda (copyMemPtr1),y
    38 A046 91 FC				sta (copyMemPtr2),y
    39 A048 C8					iny
    40 A049 D0 04				bne copyMemB1
    41 A04B E6 FF				inc copyMemPtr1+1
    42 A04D E6 FD				inc copyMemPtr2+1
    43 A04F			copyMemB1
    44 A04F A5 FA				lda copyMemCounter
    45 A051 D0 02				bne copyMemB2
    46 A053 C6 FB				dec copyMemCounter+1
    47 A055			copyMemB2
    48 A055 C6 FA				dec copyMemCounter
    50 A057 A5 FA				lda copyMemCounter
    51 A059 05 FB				ora copyMemCounter+1
    52 A05B D0 E7				bne copyMemLoop2
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\ArdungeonV4.asm
   107 A05D				CopyMemory $d800,$1600,$2800
Macro: COPYMEMORY [Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A05D A0 00			      ldy #0
    23 A05F A9 00			        lda #<$D800
    24 A061 85 FE			        sta copyMemPtr1
    25 A063 A9 D8			        lda #>$D800
    26 A065 85 FF			        sta copyMemPtr1+1
    27 A067 A9 00				lda #<$1600
    28 A069 85 FC				sta copyMemPtr2
    29 A06B A9 16				lda #>$1600
    30 A06D 85 FD				sta copyMemPtr2+1
    31 A06F A9 00				lda #<$2800
    32 A071 85 FA				sta copyMemCounter
    33 A073 A9 28				lda #>$2800
    34 A075 85 FB				sta copyMemCounter+1
    36 A077			copyMemLoop2
    37 A077 B1 FE				lda (copyMemPtr1),y
    38 A079 91 FC				sta (copyMemPtr2),y
    39 A07B C8					iny
    40 A07C D0 04				bne copyMemB1
    41 A07E E6 FF				inc copyMemPtr1+1
    42 A080 E6 FD				inc copyMemPtr2+1
    43 A082			copyMemB1
    44 A082 A5 FA				lda copyMemCounter
    45 A084 D0 02				bne copyMemB2
    46 A086 C6 FB				dec copyMemCounter+1
    47 A088			copyMemB2
    48 A088 C6 FA				dec copyMemCounter
    50 A08A A5 FA				lda copyMemCounter
    51 A08C 05 FB				ora copyMemCounter+1
    52 A08E D0 E7				bne copyMemLoop2
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\ArdungeonV4.asm
   108 A090 A9 FE 8D 01 D3		mva #$fe portb
   109 A095				CopyMemory $600,$c000,$1000				//Put OS on upper RAM
Macro: COPYMEMORY [Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A095 A0 00			      ldy #0
    23 A097 A9 00			        lda #<$600
    24 A099 85 FE			        sta copyMemPtr1
    25 A09B A9 06			        lda #>$600
    26 A09D 85 FF			        sta copyMemPtr1+1
    27 A09F A9 00				lda #<$C000
    28 A0A1 85 FC				sta copyMemPtr2
    29 A0A3 A9 C0				lda #>$C000
    30 A0A5 85 FD				sta copyMemPtr2+1
    31 A0A7 A9 00				lda #<$1000
    32 A0A9 85 FA				sta copyMemCounter
    33 A0AB A9 10				lda #>$1000
    34 A0AD 85 FB				sta copyMemCounter+1
    36 A0AF			copyMemLoop2
    37 A0AF B1 FE				lda (copyMemPtr1),y
    38 A0B1 91 FC				sta (copyMemPtr2),y
    39 A0B3 C8					iny
    40 A0B4 D0 04				bne copyMemB1
    41 A0B6 E6 FF				inc copyMemPtr1+1
    42 A0B8 E6 FD				inc copyMemPtr2+1
    43 A0BA			copyMemB1
    44 A0BA A5 FA				lda copyMemCounter
    45 A0BC D0 02				bne copyMemB2
    46 A0BE C6 FB				dec copyMemCounter+1
    47 A0C0			copyMemB2
    48 A0C0 C6 FA				dec copyMemCounter
    50 A0C2 A5 FA				lda copyMemCounter
    51 A0C4 05 FB				ora copyMemCounter+1
    52 A0C6 D0 E7				bne copyMemLoop2
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\ArdungeonV4.asm
   110 A0C8				CopyMemory $1600,$d800,$2800
Macro: COPYMEMORY [Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A0C8 A0 00			      ldy #0
    23 A0CA A9 00			        lda #<$1600
    24 A0CC 85 FE			        sta copyMemPtr1
    25 A0CE A9 16			        lda #>$1600
    26 A0D0 85 FF			        sta copyMemPtr1+1
    27 A0D2 A9 00				lda #<$D800
    28 A0D4 85 FC				sta copyMemPtr2
    29 A0D6 A9 D8				lda #>$D800
    30 A0D8 85 FD				sta copyMemPtr2+1
    31 A0DA A9 00				lda #<$2800
    32 A0DC 85 FA				sta copyMemCounter
    33 A0DE A9 28				lda #>$2800
    34 A0E0 85 FB				sta copyMemCounter+1
    36 A0E2			copyMemLoop2
    37 A0E2 B1 FE				lda (copyMemPtr1),y
    38 A0E4 91 FC				sta (copyMemPtr2),y
    39 A0E6 C8					iny
    40 A0E7 D0 04				bne copyMemB1
    41 A0E9 E6 FF				inc copyMemPtr1+1
    42 A0EB E6 FD				inc copyMemPtr2+1
    43 A0ED			copyMemB1
    44 A0ED A5 FA				lda copyMemCounter
    45 A0EF D0 02				bne copyMemB2
    46 A0F1 C6 FB				dec copyMemCounter+1
    47 A0F3			copyMemB2
    48 A0F3 C6 FA				dec copyMemCounter
    50 A0F5 A5 FA				lda copyMemCounter
    51 A0F7 05 FB				ora copyMemCounter+1
    52 A0F9 D0 E7				bne copyMemLoop2
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\ArdungeonV4.asm
   111 A0FB A9 40 8D 0E D4		mva #$40 nmien
   112 A100				CopyMemory Copy_loader2, start_loader2,(.len loader2)
Macro: COPYMEMORY [Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A100 A0 00			      ldy #0
    23 A102 A9 93			        lda #<COPY_LOADER2
    24 A104 85 FE			        sta copyMemPtr1
    25 A106 A9 A2			        lda #>COPY_LOADER2
    26 A108 85 FF			        sta copyMemPtr1+1
    27 A10A A9 00				lda #<START_LOADER2
    28 A10C 85 FC				sta copyMemPtr2
    29 A10E A9 CC				lda #>START_LOADER2
    30 A110 85 FD				sta copyMemPtr2+1
    31 A112 A9 56				lda #<(.LEN LOADER2)
    32 A114 85 FA				sta copyMemCounter
    33 A116 A9 02				lda #>(.LEN LOADER2)
    34 A118 85 FB				sta copyMemCounter+1
    36 A11A			copyMemLoop2
    37 A11A B1 FE				lda (copyMemPtr1),y
    38 A11C 91 FC				sta (copyMemPtr2),y
    39 A11E C8					iny
    40 A11F D0 04				bne copyMemB1
    41 A121 E6 FF				inc copyMemPtr1+1
    42 A123 E6 FD				inc copyMemPtr2+1
    43 A125			copyMemB1
    44 A125 A5 FA				lda copyMemCounter
    45 A127 D0 02				bne copyMemB2
    46 A129 C6 FB				dec copyMemCounter+1
    47 A12B			copyMemB2
    48 A12B C6 FA				dec copyMemCounter
    50 A12D A5 FA				lda copyMemCounter
    51 A12F 05 FB				ora copyMemCounter+1
    52 A131 D0 E7				bne copyMemLoop2
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\ArdungeonV4.asm
   113 A133 58				cli
   114 A134 18				clc	// No errors!
   115 A135 60				rts	// Done
   116 				.endp
   117 A136			Copy_init2
   118 A136			.proc init2, start_init2
   119 0480 A2 FF			ldx #$ff
   120 0482 9A				txs
   121 0483 8E FF D5			stx cart_apaga
   122 0486 AD 13 D0 8D FA 03		mva trig3 gintlk
   123 048C A9 00 8D 04 03 A9 + 	mwa #$600 dbuflo
   124 0496 A9 01 8D 0A 03 A9 + 	mwa #$01  daux1
   125 04A0 A9 52 8D 02 03		mva #$52  dcomnd
   126 04A5 20 00 04			jsr loader		//Read 1st sector
   127 04A8 A9 00 8D 33 06 A9 + 	mwa #loader $633	//Patch SIO call
   128 04B2 A9 C4 8D 3E 06 A9 + 	mwa #cont $63e		//Patch final instruction
   129 04BC A9 70 8D 2E 06		mva #$70 $62e
   130 04C1 4C 06 06			jmp $606
   131 04C4			cont
   132 				;	lda #$00
   133 				;	sta sdmctl
   134 				;	sta dmactl		//Turn screen off
   135 04C4 A9 70			lda #$70
   136 04C6 8D 05 70			sta $7005
   137 04C9 8D 19 70			sta $7019
   138 04CC 8D 20 70			sta $7020
   139 04CF 8D 3F 70			sta $703f
   140 04D2 8D 7E 70			sta $707e
   141 04D5 A9 7D			lda #$7d
   142 04D7 8D 0F 70			sta $700f
   143 04DA 8D 67 70			sta $7067
   144 04DD A9 00 8D 46 70 A9 + 	mwa #loader $7046	//Patch SIO call
   145 04E7 A9 F4 8D 41 70 A9 + 	mwa #cont2 $7041	//Patch final instruction
   146 04F1 4C 00 70			jmp $7000		//GO!
   147 04F4			cont2
   148 04F4 A9 22			lda #$22
   149 04F6 8D 2F 02			sta sdmctl
   150 04F9 8D 00 D4			sta dmactl		//Turn screen on
   151 04FC A9 00 8D 43 1E A9 + 	mwa #loader $1e43	//Patch SIO call 1
   152 0506 A9 00 8D 7D 1E A9 + 	mwa #loader $1e7d	//Patch SIO call 2
   153 0510 A9 1D 8D 7A 1E A9 + 	mwa #cont3 $1e7a	//Patch final instruction
   154 051A 4C 00 20			jmp $2000		//Execute intro!!
   155 051D			cont3
   156 051D A9 20			lda #$20		//NO "48K" display!!
   157 051F 8D 8F 81			sta $818f
   158 0522 8D 90 81			sta $8190
   159 0525 8D 91 81			sta $8191		//Done!
   160 0528 A9 4C 8D A4 81		mva #$4c $81a4		//Skip
   161 052D A9 21 8D A5 81 A9 + 	mwa #$8221 $81a5	//RAM size detection
   162
   163 				//TO DO: patch custom SIO command to $CC00
   164 				//What to know:
   165 				//	$230 = SIO drive ID ($31-$34)
   166 				//	$231 = SIO command ($52 read, $53 status, $50 put, $22 format)
   167 				//	$232 = SIO aux1 (sector number lo byte)
   168 				//	$233 = SIO aux2 (sector number hi byte)
   169 				// Pending: where to locate the buffer ($CD00? or similar.)
   170
   171 0537 A9 00 8D A1 24 A9 + 	mwa #loader2 $24a1
   172 0541 A9 02 8D E1 80		mva #$02 $80e1		//Skip Virtual D4: detection
   173 0546 A9 4C			lda #$4c		//NOPs to force detection on D1:
   174 0548 8D E0 80			sta $80e0
   175 054B A9 0D 8D E1 80 A9 + 	mwa #$810d $80e1
   176 0555 A9 EA			lda #$ea		//Store NOPs
   177 0557 8D 93 28			sta $2893		//Forces no checksum
   178 055A 8D 94 28			sta $2894		//Forces no checksum
   179 055D 8D 8B 28			sta $288b		//Forces no checksum
   180 0560 8D 8C 28			sta $288c		//Forces no checksum
   181 0563 A9 00			lda #$00
   182 0565 8D 4E 02			sta $24e		//Virtual D1: enabled!
   183 0568 8D 51 02			sta $251		//Virtual D4: enabled! 
   184 056B A9 34 8D 0E 81		mva #$34 $810e		//Use D4: as main drive
   185 0570 4C 7E 80			jmp $807e		//Go to the game!
   186 				.endp
   187
   188 A229			Copy_init3
   189
   190 				// Now, we put the loader
   191 A229			Copy_Loader
   192 A229			.proc	loader , start_loader
   193 0400 78				sei		// No IRQs!
   194 0401 AD 0E D4			lda nmien	// Save NMIEN
   195 0404 48				pha		// Store it
   196 0405 A9 00			lda #$00	
   197 0407 8D 0E D4			sta nmien	// No NMIs!
   198 040A AD 04 03			lda dbuflo	// Take LSB of the address to store
   199 040D 85 32			sta bufrlo	// Store it on Page Zero!
   200 040F AD 05 03			lda dbufhi	// Take MSB of the addres to store
   201 0412 85 33			sta bufrhi	// Store it!
   202 0414 38				sec		// Let's substract 1
   203 0415 AD 0A 03			lda daux1	// To the sector number!
   204 0418 E9 01			sbc #$01
   205 041A 85 34			sta aux1	// Store it!
   206 041C AD 0B 03			lda daux2	// Take MSB of the sector to read
   207 041F E9 00			sbc #$00	// Make sure we store it
   208 0421 85 35			sta aux2	// on page zero!
   209 0423 18				clc		// Clear the carry.
   210 0424 A5 34			lda aux1	// Take new sector number
   211 0426 48				pha		// save it!
   212 					.if FLAG_16KB = 0
   213 0427 29 C0				and #$c0	// Take bits 6 and 7
   214 					.else
   215 						and #$80	//In case of 16 kb banks just take bit 7
   216
   217 					.endif
   218 0429 4A 4A 4A 4A 4A 4A		:6 lsr		// Move it to bit 0 and 1!
   219 					.if FLAG_16KB = 1
   220 						lsr	// Or bit 7 to 0 in case of 16kb banks
   221 					.endif
   222 042F 85 34			sta aux1	// Store it!
   223 0431 A5 35			lda aux2	// Take MSB of the sector.
   224 0433 0A				asl		// Move 2 bits to the left! Bits 0 and 1 are zero 
   225 					.if FLAG_16KB = 0 //Or 1 bit if it's a Megacart
   226 0434 0A					asl		// Done!
   227 					.endif
   228 0435 05 34			ora aux1	// Put bits 0 and 1 on from the previous calculation 
   229 0437 18				clc		// Preparing to add 1
   230 = 0439			parameter=*+1		// IMPORTANT: the parameter sets the initial side from the disk. Originally, 1
   231 0438 69 01			adc #$01	// Add it!
   232 043A 85 36			sta c_bank	// Store cartridge bank!
   233 043C 68				pla		// take previous LSB of the sector number.
   234 					.if FLAG_16KB = 0
   235 043D 29 3F				and #$3F	// Take bits from 0 to 5. Bits 6 and 7 were previously taken to calculate the cartridge bank.
   236 					.else
   237 						and #$7f	// Take bits from 0 to 6. Bit 7 was previously taken to calculate the cartridge bank
   238 					.endif
   239 043F 4A				lsr		// Shift bit 0 to carry flag. That way, we'll know if the LSB to read on the cartridge is $00 or $80
   240 0440 09 A0			ora #>start_cartridge	// Establish the initial address from the cartridge
   241 0442 85 35			sta aux2	// Store it as MSB from the address to read from the cartridge
   242 0444 A9 00			lda #$00	// Taking carry
   243 0446 6A				ror		// To determine if LSB is $00 or $80
   244 0447 85 34			sta aux1	// Save it!
   245 0449 A0 7F			ldy #$7F	// Number of bytes to read from cartridge (128)
   246 044B			loop
   247 044B A5 36			lda c_bank	// First, we take the cartridge bank calculated
   248 044D AA				tax		// Transfer to register X
   249 044E 9D 00 D5			sta $d500,x	// And save to the cartridge control area. This way I can use Data bus or address bus bank-switching methods 
   250 0451 B1 34			lda (aux1),y	// Read the byte from the cartridge
   251 0453 48				pha		// Store it before turning off the cartridge
   252 0454 A9 FF			lda #$FF	// Let's turn the cartridge off
   253 0456 8D FF D5			sta cart_apaga	// Done!
   254 0459 68				pla		// Recover byte reading
   255 045A 91 32			sta (bufrlo),y	// Store it to the final address
   256 045C 88				dey		// Are we done with the byte copying?
   257 045D 10 EC			bpl loop	// Not yet
   258 045F 68				pla		// Ending the cartridge reading process. Now we recover the computer status
   259 0460 8D 0E D4			sta nmien	// Recover NMIs
   260 0463 58				cli		// Recover IRQs
   261 0464 A0 01			ldy #$01	// All done without errors
   262 0466 8C 03 03			sty dstats	// Save it to DSTATS!
   263 0469 60				rts		// BYE!!
   264 046A			fin_loader
   265 				.endp
   266
   267 A293			Copy_loader2
   268 A293			.proc	loader2 , start_loader2
   269
   270 				;aux1 = $02
   271 				;aux2 = aux1+1
   272 = 0230			drivenum =$230
   273 = 0231			drivecommand =$231
   274 = 0232			driveseclo =$232
   275 = 0233			drivesechi =$233
   276 = 023D			status1 = $23d
   277 = 0246			status2 = $246
   278 = 0100			buffer = $100
   279 CC00 AD 30 02			lda drivenum
   280 CC03 C9 34			cmp #$34	//Is virtual D4: drive?
   281 CC05 F0 03 4C 9B CC		jne drive1	//No! It's the character disk.
   282 				//	beq drive4
   283 				//	jmp $204e	// Use the disk drive!!!
   284 CC0A			drive4	
   285 CC0A 78				sei		// No IRQs!
   286 CC0B A9 00			lda #$00	
   287 CC0D 8D 0E D4			sta nmien	// No NMIs!
   288
   289 CC10 38				sec		// Let's substract 1
   290 CC11 AD 32 02			lda driveseclo	// To the sector number!
   291 CC14 E9 01			sbc #$01
   292 CC16 8D 57 CC			sta d4_aux1	// Store it!
   293 CC19 AD 33 02			lda drivesechi	// Take MSB of the sector to read
   294 CC1C E9 00			sbc #$00	// Make sure we store it
   295 CC1E 8D 58 CC			sta d4_aux2	// on page zero!
   296 CC21 18				clc		// Clear the carry.
   297 CC22 AD 57 CC			lda d4_aux1	// Take new sector number
   298 CC25 48				pha		// save it!
   299 					.if FLAG_16KB = 0
   300 CC26 29 C0				and #$c0	// Take bits 6 and 7
   301 					.else
   302 						and #$80	//In case of 16 kb banks just take bit 7
   303
   304 					.endif
   305 CC28 4A 4A 4A 4A 4A 4A		:6 lsr		// Move it to bit 0 and 1!
   306 					.if FLAG_16KB = 1
   307 						lsr	// Or bit 7 to 0 in case of 16kb banks
   308 					.endif
   309 CC2E 8D 57 CC			sta d4_aux1	// Store it!
   310 CC31 AD 58 CC			lda d4_aux2	// Take MSB of the sector.
   311 CC34 0A				asl		// Move 2 bits to the left! Bits 0 and 1 are zero 
   312 					.if FLAG_16KB = 0 //Or 1 bit if it's a Megacart
   313 CC35 0A					asl		// Done!
   314 					.endif
   315 CC36 0D 57 CC			ora d4_aux1	// Put bits 0 and 1 on from the previous calculation 
   316 CC39 18				clc		// Preparing to add 1
   317 = CC3B			d4_parameter=*+1	// IMPORTANT: the parameter sets the initial side from the disk. Originally, 1
   318 CC3A 69 01			adc #$01	// Add it!
   319 CC3C 8D 51 CC			sta d4_c_bank	// Store cartridge bank!
   320 CC3F 68				pla		// take previous LSB of the sector number.
   321 					.if FLAG_16KB = 0
   322 CC40 29 3F				and #$3F	// Take bits from 0 to 5. Bits 6 and 7 were previously taken to calculate the cartridge bank.
   323 					.else
   324 						and #$7f	// Take bits from 0 to 6. Bit 7 was previously taken to calculate the cartridge bank
   325 					.endif
   326 CC42 4A				lsr		// Shift bit 0 to carry flag. That way, we'll know if the LSB to read on the cartridge is $00 or $80
   327 CC43 09 A0			ora #>start_cartridge	// Establish the initial address from the cartridge
   328 CC45 8D 58 CC			sta d4_aux2	// Store it as MSB from the address to read from the cartridge
   329 CC48 A9 00			lda #$00	// Taking carry
   330 CC4A 6A				ror		// To determine if LSB is $00 or $80
   331 CC4B 8D 57 CC			sta d4_aux1	// Save it!
   332 CC4E A0 7F			ldy #$7F	// Number of bytes to read from cartridge (128)
   333 CC50			d4_ldacbank
   334 CC50 A9 FF			lda #$FF	// First, we take the cartridge bank calculated
   335 = CC51			d4_c_bank = d4_ldacbank+1
   336 CC52 AA				tax		// Transfer to register X
   337 CC53 9D 00 D5			sta $d500,x	// And save to the cartridge control area. This way I can use Data bus or address bus bank-switching methods 
   338 CC56			d4_loop
   339 CC56 B9 FF FF			lda $FFFF,y	// Read the byte from the cartridge
   340 = CC57			d4_aux1 = d4_loop+1
   341 = CC58			d4_aux2 = d4_aux1+1
   342 CC59 99 00 01			sta buffer,y	// Store it to the final address
   343 CC5C 88				dey		// Are we done with the byte copying?
   344 CC5D 10 F7			bpl d4_loop	// Not yet
   345 CC5F A9 FF			lda #$ff
   346 CC61 8D FF D5			sta cart_apaga
   347 CC64 A9 C0			lda #$c0	// Ending the cartridge reading process. Now we recover the computer status
   348 CC66 8D 0E D4			sta nmien	// Recover NMIs
   349 CC69 58				cli		// Recover IRQs
   350 CC6A A0 01			ldy #$01	// All done without errors
   351 CC6C 8C 3D 02			sty status1	// Save it to DSTATS!
   352 CC6F 8C 46 02			sty status2
   353 CC72 60				rts		// BYE!!
   354
   355
   356 CC73			sec_table		//List of initial sectors to write on 
   357
   358 				//This table marks the sectors we'll take into account to erase the entire sector.
   359 				//That is, the initial disk sector from we'll erase.
   360 CC73 02 00 03 00 BB 00 + 	.word $0002,$0003,$00bb,$0173,$022b
   361 CC7D			offset_table
   362 CC7D 01 00 03 00 BB 00 + 	.word $0001,$0003,$00bb,$0173,$022b
   363 CC87			sec_offset
   364 CC87 00 00			.word $0000	//Sector offset to substract from original cartridge sector.
   365 				//bank_table		//List of initial bank per sector. The first 10 sectors are for D4:. Banks $0a-$0f to D1:
   366 CC89 00 00 00 00 00 00 + 	.by $00,$00,$00,$00,$00,$00,$00,$00,$00,$00
   367 CC93			bank_table
   368 CC93 50 58 60 68 70 78		.by $50,$58,$60,$68,$70,$78
   369 CC99			sector_selected
   370 CC99 00				.by $00		//By default, sector 0
   371 CC9A			bank_selected
   372 CC9A 00				.by $00		//By default, bank 0
   373 CC9B			drive1
   374 CC9B AD 31 02			lda drivecommand
   375 CC9E C9 21			cmp #$21	//Is it a format command?
   376 CCA0 D0 27			jne no_format	//No! It's a write or read
   377
   378 				//Let's format it! Will erase all sectors for D1:
   379 CCA2 A9 0A			lda #$0a
   380 CCA4 20 E4 CD			jsr erasebk	//Erase bank $0a (Header info)
   381 CCA7 A9 0B			lda #$0b
   382 CCA9 20 E4 CD			jsr erasebk	//Erase bank $0b (save state 1)
   383 CCAC A9 0C			lda #$0c
   384 CCAE 20 E4 CD			jsr erasebk	//Erase bank $0c (save state 2)
   385 CCB1 A9 0D			lda #$0d
   386 CCB3 20 E4 CD			jsr erasebk	//Erase bank $0d (save state 3)
   387 CCB6 A9 0E			lda #$0e
   388 CCB8 20 E4 CD			jsr erasebk	//Erase bank $0e (save state 4)
   389 CCBB A9 FF			lda #$ff
   390 CCBD 8D FF D5			sta cart_apaga
   391 CCC0 A0 01			ldy #$01	// All done without errors
   392 CCC2 8C 3D 02			sty status1	// Save it to DSTATS!
   393 CCC5 8C 46 02			sty status2
   394 CCC8 60				rts		//Formatting successful
   395 CCC9			no_format
   396
   397
   398 				//	rts		//NEED TO BE REMOVED!!!!
   399
   400
   401 CCC9 48				pha		//Store command for a while
   402 				//Now will check if it's the initial sector from the block of the disk.
   403 				//In case it's the initial one, it erases the entire sector
   404 CCCA A2 00			ldx #$00	//Counter
   405 CCCC 8E 99 CC			stx sector_selected
   406 CCCF A0 01			ldy #$01	//Start with no detection!!
   407 CCD1			d1_loop1
   408 CCD1 AD 33 02			lda drivesechi		//Take MSB of the sector
   409 CCD4 DD 74 CC			cmp sec_table+1,x	//Is it from the table?
   410 CCD7 F0 04			beq d1_loop1_0 
   411 CCD9 90 12			bcc d1_loop2		//NO! It's higher. Don't count this.
   412 CCDB D0 0D			bne d1_loop1_2		//No! It's lower. Take x to the sector selected.
   413
   414 CCDD			d1_loop1_0
   415 CCDD AD 32 02			lda driveseclo		//It's equal. Now let's get LSB of the sector.
   416 CCE0 DD 73 CC			cmp sec_table,x		//Is it from the table?
   417 CCE3 F0 04			beq d1_loop1_1
   418 CCE5 90 06			bcc d1_loop2		//No, it's higher. next sector!
   419 CCE7 D0 01			bne d1_loop1_2		//No, it's lower. Take x to the sector selected.
   420 CCE9			d1_loop1_1
   421 CCE9 88				dey			//It's the same! Put Y = 0.
   422 CCEA			d1_loop1_2
   423 CCEA 8E 99 CC			stx sector_selected
   424 CCED			d1_loop2
   425 CCED E8				inx
   426 CCEE E8				inx
   427 CCEF E0 0A			cpx #$0a	//All 5 sectors checked?
   428 CCF1 D0 DE			bne d1_loop1	//Not yet!
   429 CCF3 AE 99 CC			ldx sector_selected
   430 CCF6 BD 7D CC			lda offset_table,x	//Take the offset
   431 CCF9 8D 87 CC			sta sec_offset		//Store it!
   432 CCFC BD 7E CC			lda offset_table+1,x	//MSB offset
   433 CCFF 8D 88 CC			sta sec_offset+1	//Store it!
   434 CD02 4E 99 CC			lsr sector_selected
   435 CD05 AE 99 CC			ldx sector_selected
   436 CD08 BD 93 CC			lda bank_table,x
   437 CD0B 8D 41 CD			sta d1_parameter	//Change initial bank to take
   438
   439 CD0E			drive1_put
   440 CD0E 78				sei		// No IRQs!
   441 CD0F A9 00			lda #$00	
   442 CD11 8D 0E D4			sta nmien	// No NMIs!
   443
   444 CD14 38				sec		// Let's substract 1
   445 CD15 AD 32 02			lda driveseclo	// To the sector number!
   446 CD18 ED 87 CC			sbc sec_offset
   447 CD1B 8D 6B CD			sta d1_read_aux1	// Store it!
   448 CD1E AD 33 02			lda drivesechi	// Take MSB of the sector to read
   449 CD21 ED 88 CC			sbc sec_offset+1	// Make sure we store it
   450 CD24 8D 6C CD			sta d1_read_aux2	// on page zero!
   451 CD27 18				clc		// Clear the carry.
   452 CD28 AD 6B CD			lda d1_read_aux1	// Take new sector number
   453 CD2B 48				pha		// save it!
   454 CD2C 29 C0			and #$c0	// Take bits 6 and 7
   455 CD2E 4A 4A 4A 4A 4A 4A		:6 lsr		// Move it to bit 0 and 1!
   456 CD34 8D 6B CD			sta d1_read_aux1	// Store it!
   457 CD37 AD 6C CD			lda d1_read_aux2	// Take MSB of the sector.
   458 CD3A 0A				asl		// Move 2 bits to the left! Bits 0 and 1 are zero 
   459 CD3B 0A				asl		// Done!
   460 CD3C 0D 6B CD			ora d1_read_aux1	// Put bits 0 and 1 on from the previous calculation 
   461 CD3F 18				clc		// Preparing to add 1
   462 = CD41			d1_parameter=*+1	// IMPORTANT: the parameter sets the initial side from the disk. Originally, 1
   463 CD40 69 01			adc #$01	// Add it!
   464 CD42 8D 65 CD			sta d1_read_c_bank	// Store cartridge bank!
   465 CD45 8D 82 CD			sta d1_write_c_bank
   466 CD48 68				pla		// take previous LSB of the sector number.
   467 CD49 29 3F			and #$3F	// Take bits from 0 to 5. Bits 6 and 7 were previously taken to calculate the cartridge bank.
   468 CD4B 4A				lsr		// Shift bit 0 to carry flag. That way, we'll know if the LSB to read on the cartridge is $00 or $80
   469 CD4C 09 A0			ora #>start_cartridge	// Establish the initial address from the cartridge
   470 CD4E 8D 6C CD			sta d1_read_aux2	// Store it as MSB from the address to read from the cartridge
   471 CD51 8D 8B CD			sta d1_write_aux2
   472 CD54 A9 00			lda #$00	// Taking carry
   473 CD56 6A				ror		// To determine if LSB is $00 or $80
   474 CD57 8D 6B CD			sta d1_read_aux1	// Save it!
   475 CD5A 8D 8A CD			sta d1_write_aux1
   476
   477 				//Now we start to copy the bytes (read/write)
   478
   479 CD5D A2 7F			ldx #$7f
   480 CD5F 68				pla		//Restore command
   481 CD60 C9 57			cmp #$57	//Write?
   482 CD62 F0 11			beq d1_write
   483 CD64			d1_read_ldacbank
   484 CD64 A9 FF			lda #$ff
   485 = CD65			d1_read_c_bank =d1_read_ldacbank+1
   486 CD66 A8				tay
   487 CD67 99 00 D5			sta $d500,y
   488 CD6A			d1_read_loop
   489 CD6A BD FF FF			lda $FFFF,x	// Read the byte from the cartridge
   490 = CD6B			d1_read_aux1 = d1_read_loop+1
   491 = CD6C			d1_read_aux2 = d1_read_aux1+1
   492 CD6D 9D 00 01			sta buffer,x	// Store it to the final address
   493 CD70 CA				dex		// Are we done with the byte copying?
   494 CD71 10 F7			bpl d1_read_loop	// Not yet
   495 CD73 30 1A			bmi d1_end	//Let's finish
   496
   497 CD75			d1_write
   498 CD75 98				tya		//Is is first sector?
   499 CD76 D0 09			bne d1_write_cont	//Nope, let's continue
   500 CD78 AD 99 CC			lda sector_selected	
   501 CD7B 18				clc
   502 CD7C 69 0A			adc #$0a
   503 CD7E 20 E4 CD			jsr erasebk		//Erase the bank and start writing!
   504 CD81			d1_write_cont
   505
   506 CD81			d1_write_loop
   507 CD81			d1_write_ldacbank
   508 CD81 A9 FF			lda #$ff
   509 = CD82			d1_write_c_bank =d1_write_ldacbank+1
   510 CD83 20 C3 CD			jsr enable_write
   511 CD86 BD 00 01			lda buffer,x
   512 CD89			d1_write_sta	
   513 CD89 9D FF FF			sta $FFFF,x
   514 = CD8A			d1_write_aux1 = d1_write_sta+1
   515 = CD8B			d1_write_aux2 = d1_write_aux1+1
   516 CD8C CA				dex
   517 CD8D 10 F2			bpl d1_write_loop
   518
   519 CD8F			d1_end
   520 CD8F A9 FF			lda #$ff
   521 CD91 8D FF D5			sta cart_apaga
   522 CD94 A9 C0			lda #$c0	// Ending the cartridge reading process. Now we recover the computer status
   523 CD96 8D 0E D4			sta nmien	// Recover NMIs
   524 CD99 58				cli		// Recover IRQs
   525 CD9A A0 01			ldy #$01	// All done without errors
   526 CD9C 8C 3D 02			sty status1	// Save it to DSTATS!
   527 CD9F 8C 46 02			sty status2
   528 CDA2 60				rts		// BYE!!
   529
   530
   531
   532 CDA3			fcode
   533 CDA3			setsec
   534 CDA3 29 0F			and #$0F	//Only $00-$0F allowed
   535 CDA5 18				clc		//Just to not set bit 7 to 1 accidentally
   536 CDA6 2A				rol		//*2
   537 CDA7 2A				rol		//*4
   538 CDA8 2A				rol		//*8
   539 CDA9 AA				tax
   540 CDAA 9D 00 D5			sta $d500,x	//Change bank!
   541 CDAD 60				rts
   542
   543 CDAE			wr5555
   544 CDAE 8D 42 D5			sta $d542
   545 CDB1 8D 55 B5			sta $b555
   546 CDB4 60				rts
   547
   548 CDB5			cmd_unlock
   549 CDB5 A9 AA			lda #$AA
   550 CDB7 20 AE CD			jsr wr5555
   551 CDBA A9 55			lda #$55
   552
   553 CDBC			wr2AAA
   554 CDBC 8D 41 D5			sta $d541
   555 CDBF 8D AA AA			sta $aaaa
   556 CDC2 60				rts
   557 					
   558 CDC3			enable_write
   559 CDC3 8E 22 CE			stx temp_x
   560 CDC6 48				pha
   561 CDC7 20 B5 CD			jsr cmd_unlock
   562 CDCA A9 A0			lda #$a0
   563 CDCC 20 AE CD			jsr wr5555
   564 CDCF			enable_write_cont
   565 CDCF 68				pla
   566 CDD0 AA				tax
   567 CDD1 9D 00 D5			sta $d500,x
   568 CDD4 AE 22 CE			ldx temp_x
   569 CDD7 60				rts
   570 					
   571 CDD8			enable_read
   572 CDD8 48				pha
   573 CDD9 20 B5 CD			jsr cmd_unlock
   574 CDDC A9 F0			lda #$f0
   575 CDDE 20 AE CD			jsr wr5555
   576 CDE1 4C CF CD			jmp enable_write_cont
   577 CDE4			erasebk
   578 CDE4 8E 22 CE			stx temp_x
   579 CDE7 48				pha
   580 CDE8 20 B5 CD			jsr cmd_unlock		//First two cycles!
   581 CDEB A9 80			lda #$80
   582 CDED 20 AE CD			jsr wr5555		//Third cycle!
   583 CDF0 20 B5 CD			jsr cmd_unlock		//Fourth and fifth cycles!
   584 CDF3 68				pla
   585 CDF4 20 A3 CD			jsr setsec
   586 CDF7 A9 30			lda #$30		//Sixth and final cycle!
   587 CDF9 8D 00 A0			sta start_cartridge	//Erase!
   588 					
   589
   590 CDFC			poll_write
   591 CDFC A9 00			lda #$00
   592 CDFE 8D 21 CE			sta pollsame
   593 CE01			@poll_again
   594 CE01 AD 00 A0			lda start_cartridge
   595 CE04 CD 00 A0			cmp start_cartridge
   596 CE07 D0 F3			bne poll_write
   597 CE09 CD 00 A0			cmp start_cartridge
   598 CE0C D0 EE			bne poll_write
   599 CE0E CD 00 A0			cmp start_cartridge
   600 CE11 D0 E9			bne poll_write
   601 CE13 EE 21 CE			inc pollsame
   602 CE16 D0 E9			bne @poll_again
   603 CE18 A9 FF			lda #$ff
   604 CE1A 8D FF D5			sta cart_apaga
   605 CE1D AE 22 CE			ldx temp_x
   606 CE20 60				rts
   607 CE21			pollsame
   608 CE21 00				.by $00
   609 CE22 00			temp_x	.by $00
   610 					
   611 				//	icl "fcode.s"	//Courtesy from Wrathchild at Atariage. Thanks!
   612
   613 CE23			chipmask
   614 CE23 00				.byte $00
   615 CE24			final_greeting
   616 CE24 23 61 72 74 72 69 + 	.byte "Cartridge version (C) 2020 by Guillermo Fuenzalida"
   617 CE56			fin_loader
   618 				.endp
   619
   620 					opt f+		//start filling!
   621 					
   622 A4E9				org end_bank-6-3	//// Put it into the end
   623 BFF7 4C 00 A0			jmp init
   624 BFFA 80 04			.word init2		// Second init address first.
   625 BFFC 00 04			.byte $00,$04		// Parameters to not to call to Disk.
   626 BFFE 00 A0			.word init		// First init address
   627 					opt f-			// No more filling!
   628
   629 				// Bank 2
   630 C000				org start_cartridge
   631 01,A000				lmb #$01
   632 01,A000			start_atr
   633 01,A000 01 01 00 06 06 + 	ins "ARD_WIP_rel3.atr",16
   634 01,09A000		end_atr
   635
   636 				//Now we fill till we got cartridge size
   637
   638 = 01,090000		total_bytes	= end_atr - start_atr		//Total bytes of ATR
   639 = 01,2000		bank_size	= end_bank - start_cartridge
   640
   641 = 01,0049		banks_used = ((total_bytes+(bank_size-1))/bank_size)+1
   642 = 01,0037		filler_banks = cart_banks - banks_used
   643 = 01,0000		filler_bytes = bank_size*(banks_used-1)-total_bytes
   644
   645 				; Llenamos los bytes
   646
   647 				.if filler_banks > 0
   648 01,09A000			.sav filler_bytes
   649 				.else
   650 					.sav filler_bytes - 6 -8
   651 				.endif
   652
   653 01,09A000		end_file
   654
   655
   656 				.if filler_banks > 0
   657 					.if filler_banks > 1
   658 						.rept filler_banks-1
   659 							.SAV BANK_SIZE
   660 						.ENDR
   660 						.endr
Source: REPT
   659 01,09A000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,09C000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,09E000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0A0000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0A2000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0A4000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0A6000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0A8000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0AA000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0AC000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0AE000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0B0000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0B2000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0B4000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0B6000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0B8000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0BA000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0BC000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0BE000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0C0000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0C2000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0C4000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0C6000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0C8000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0CA000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0CC000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0CE000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0D0000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0D2000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0D4000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0D6000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0D8000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0DA000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0DC000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0DE000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0E0000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0E2000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0E4000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0E6000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0E8000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0EA000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0EC000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0EE000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0F0000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0F2000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0F4000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0F6000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0F8000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0FA000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0FC000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,0FE000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,100000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,102000 00 00 00 00 +  			.SAV BANK_SIZE
   659 01,104000 00 00 00 00 +  			.SAV BANK_SIZE
Source: C:\jac\wudsn\Workspace\Atari800\Prueba Atari\BOOTCartridge\Alternate Reality - The dungeon\ArdungeonV4.asm
   661 					.endif
   662 01,106000 00 00 00 00 +  	.sav bank_size-6-8
   663 				.endif
   664
   665
   666 01,107FF2 A9 00			lda #$00
   667 01,107FF4 8D 00 D5		sta $d500
   668 01,107FF7 4C 00 A0		jmp init
   669 01,107FFA 80 04			.word init2
   670 01,107FFC 00 04			.byte $00,$04
   671 01,107FFE F2 BF			.word $bff2
