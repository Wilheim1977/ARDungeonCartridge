mads 2.1.0 build 8 (23 Dec 19)
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
     1 				// ****************************************************
     2 				// *                                                  *
     3 				// * Generic BOOT Cartridge routine                   *
     4 				// *                                                  *
     5 				// *     (C) Guillermo Fuenzalida (Willysoft)         *
     6 				// *                                                  *
     7 				// ****************************************************
     8
     9 				//Alternate Reality: The Dungeon Cartridge conversion
    10
    11 				//History:
    12
    13 				//V10: bugfix: game hangs when putting a wrong floppy or atr image, going to the cartridge and not returning to D1:
    14 				//V9: added 3 seconds of waiting in the credit screen. You can skip it by pressing a key, consol key or joystick button.
    15 				//V8: various bug fixes and optimized D1: access
    16 				//V7: Added D1:functionality from physical drive.
    17 				//V6: relocating initialization routines, now it boots faster! Changed title credits.
    18 				//	Removed SPACE BAR waiting routine when saving character.
    19 				//	Removed SPACE BAR waiting routing when resuming character.
    20 				//V5: added OPTION key detection. If pressed, then boots the disk. Optimizing booting sequence
    21 				//V4: added writing header and character data on flash cartridge. Now it's fully cartridge operational.
    22 				//V3: added format character disk.
    23 				//V2: bug fixes, now the game loads and work. Need floppy disk to save character.
    24 				//V1: initial release. Can load the menu. Game doesn't work.
    25
    26 				// First, we will define the extension as .rom
    27
    28 				;	@com.wudsn.ide.asm.outputfileextension=.rom
    29
    30 				// Now we set no binary headers
    31
    32 					opt h-
    33
    34 				; include files, useful macros:
    35 					icl "../../base/sys_equates.m65"
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_equates.m65
     1 				;================================================================================
     2 				; System equates, Atari XL + mads [NRV 2009]
     3 				;================================================================================
     4
     5 				;----------------------------------------
     6 				; GTIA:
     7 				;----------------------------------------
     8
     9 = D000			M0PF	= $D000  ; read only
    10 = D001			M1PF	= $D001  ; read only
    11 = D002			M2PF	= $D002  ; read only
    12 = D003			M3PF	= $D003  ; read only
    13
    14 = D004			P0PF	= $D004  ; read only
    15 = D005			P1PF	= $D005  ; read only
    16 = D006			P2PF	= $D006  ; read only
    17 = D007			P3PF	= $D007  ; read only
    18
    19 = D008			M0PL	= $D008  ; read only
    20 = D009			M1PL	= $D009  ; read only
    21 = D00A			M2PL	= $D00A  ; read only
    22 = D00B			M3PL	= $D00B  ; read only
    23
    24 = D00C			P0PL	= $D00C  ; read only
    25 = D00D			P1PL	= $D00D  ; read only
    26 = D00E			P2PL	= $D00E  ; read only
    27 = D00F			P3PL	= $D00F  ; read only
    28
    29 = D010			TRIG0	= $D010  ; read only
    30 = D011			TRIG1	= $D011  ; read only
    31 = D012			TRIG2	= $D012  ; read only
    32 = D013			TRIG3	= $D013  ; read only
    33
    34 = D014			PAL		= $D014  ; read only
    35
    36 				; positions for normal screen: 48 left (+160)--> 208 right (or 32-->224 for wide playfield)
    37 				; 32 top (+192)--> 224 bottom (or 16-->112 for double line resolution)
    38 = D000			HPOSP0	= $D000  ; write only
    39 = D001			HPOSP1	= $D001  ; write only
    40 = D002			HPOSP2	= $D002  ; write only
    41 = D003			HPOSP3	= $D003  ; write only
    42
    43 = D004			HPOSM0	= $D004  ; write only
    44 = D005			HPOSM1	= $D005  ; write only
    45 = D006			HPOSM2	= $D006  ; write only
    46 = D007			HPOSM3	= $D007  ; write only
    47
    48 				; 0 (or 2) normal width, 1 double width, 4 quadruple width
    49 = D008			SIZEP0	= $D008  ; write only
    50 = D009			SIZEP1	= $D009  ; write only
    51 = D00A			SIZEP2	= $D00A  ; write only
    52 = D00B			SIZEP3	= $D00B  ; write only
    53
    54 = D00C			SIZEM	= $D00C  ; write only		// the same 2 bits as the players, but in one byte, in this order: m3m2m1m0
    55
    56 = D00D			GRAFP0	= $D00D  ; write only
    57 = D00E			GRAFP1	= $D00E  ; write only
    58 = D00F			GRAFP2	= $D00F  ; write only
    59 = D010			GRAFP3	= $D010  ; write only
    60
    61 = D011			GRAFM	= $D011  ; write only		// 4 missiles in this order: m3m2m1m0
    62
    63 = D012			COLPM0	= $D012  ; write only
    64 = D013			COLPM1	= $D013  ; write only
    65 = D014			COLPM2	= $D014  ; write only
    66 = D015			COLPM3	= $D015  ; write only
    67
    68 = D016			COLPF0	= $D016  ; write only
    69 = D017			COLPF1	= $D017  ; write only
    70 = D018			COLPF2	= $D018  ; write only
    71 = D019			COLPF3	= $D019  ; write only
    72
    73 = D01A			COLBK	= $D01A  ; write only
    74
    75 = D01B			PRIOR	= $D01B  ; write only
    76 = D01C			VDELAY	= $D01C  ; write only
    77 = D01D			GRACTL	= $D01D  ; write only
    78 = D01E			HITCLR	= $D01E  ; write only
    79
    80 = D01F			CONSOL	= $D01F  ; read and write
    81
    82 				;----------------------------------------
    83 				; POKEY:
    84 				;----------------------------------------
    85
    86 = D200			POT0	= $D200  ; read only
    87 = D201			POT1	= $D201  ; read only
    88 = D202			POT2	= $D202  ; read only
    89 = D203			POT3	= $D203  ; read only
    90 = D204			POT4	= $D204  ; read only
    91 = D205			POT5	= $D205  ; read only
    92 = D206			POT6	= $D206  ; read only
    93 = D207			POT7	= $D207  ; read only
    94
    95 = D208			ALLPOT	= $D208  ; read only
    96
    97 = D209			KBCODE	= $D209  ; read only
    98 = D20A			RANDOM	= $D20A  ; read only
    99
   100 = D20D			SERIN	= $D20D  ; read only
   101 = D20E			IRQST	= $D20E  ; read only
   102 = D20F			SKSTAT	= $D20F  ; read only
   103
   104
   105 = D200			AUDF1	= $D200  ; write only
   106 = D201			AUDC1	= $D201  ; write only
   107 = D202			AUDF2	= $D202  ; write only
   108 = D203			AUDC2	= $D203  ; write only
   109 = D204			AUDF3	= $D204  ; write only
   110 = D205			AUDC3	= $D205  ; write only
   111 = D206			AUDF4	= $D206  ; write only
   112 = D207			AUDC4	= $D207  ; write only
   113
   114 = D208			AUDCTL	= $D208  ; write only
   115
   116 = D209			STIMER	= $D209  ; write only
   117 = D20A			SKREST	= $D20A  ; write only
   118 = D20B			POTGO	= $D20B  ; write only
   119
   120 = D20D			SEROUT	= $D20D  ; write only
   121 = D20E			IRQEN	= $D20E  ; write only
   122 = D20F			SKCTL	= $D20F  ; write only
   123
   124 				;----------------------------------------
   125 				; PIA:
   126 				;----------------------------------------
   127
   128 = D300			PORTA	= $D300  ; read and write
   129 = D301			PORTB	= $D301  ; read and write
   130 = D302			PACTL	= $D302  ; read and write
   131 = D303			PBCTL	= $D303  ; read and write
   132
   133 				;----------------------------------------
   134 				; ANTIC:
   135 				;----------------------------------------
   136
   137 = D40B			VCOUNT	= $D40B  ; read only
   138
   139 = D40C			PENH	= $D40C  ; read only
   140 = D40D			PENV	= $D40D  ; read only
   141
   142 = D40F			NMIST	= $D40F  ; read only
   143
   144
   145 = D400			DMACTL	= $D400  ; write only
   146 = D401			CHACTL	= $D401  ; write only
   147 = D402			DLISTL	= $D402  ; write only
   148 = D403			DLISTH	= $D403  ; write only
   149 = D404			HSCROL	= $D404  ; write only
   150 = D405			VSCROL	= $D405  ; write only
   151 = D407			PMBASE	= $D407  ; write only
   152 = D409			CHBASE	= $D409  ; write only
   153 = D40A			WSYNC	= $D40A  ; write only
   154 = D40E			NMIEN	= $D40E  ; write only
   155 = D40F			NMIRES	= $D40F  ; write only
   156
   157 				;----------------------------------------
   158 				; Shadow registers:
   159 				;----------------------------------------
   160
   161 = 0218			CDTMV1	= $218
   162 = 021A			CDTMV2	= $21a
   163 = 021C			CDTMV3	= $21c
   164 = 021E			CDTMV4	= $21e
   165 = 0220			CDTMV5	= $220
   166
   167
   168 = 022F			SDMCTL	= $22f	; shadow of DMACTL
   169 = 026F			GPRIOR	= $26f	; shadow of PRIOR
   170
   171 = 02C0			PCOLR0	= $2c0	; shadow of COLPM0
   172 = 02C1			PCOLR1  = $2c1
   173 = 02C2			PCOLR2  = $2c2
   174 = 02C3			PCOLR3  = $2c3
   175 = 02C4			COLOR0	= $2c4	; shadow of COLPF0
   176 = 02C5			COLOR1  = $2c5
   177 = 02C6			COLOR2  = $2c6
   178 = 02C7			COLOR3  = $2c7
   179 = 02C8			COLOR4  = $2c8
   180
   181 = 02E0			RUNAD	= $2e0
   182 = 02E2			INITAD	= $2e2
   183
   184 = 0014			RTCLOCK	= $14
   185 = 0041			SOUNDR	= $41
   186 = 0042			CRITIC	= $42
   187 = 004D			ATRACT	= 77
   188
   189 = 0052			LMARGN = $52
   190 = 0053			RMARGN = $53
   191 = 0062			PALNTS = $62
   192 = 006A			RAMTOP = $6A
   193
   194 = 02F4			CHBAS	= $2F4	; shadow of CHBASE
   195 = 02FC			CH	= $2FC
   196 = 02F3			CHACT	= $2F3  ; 
   197
   198 = 0340			ICHID = $340
   199 = 0341			ICDNO = $341
   200 = 0342			ICCMD = $342
   201 = 0343			ICSTA = $343
   202 = 0344			ICBAL = $344
   203 = 0345			ICBAH = $345
   204 = 0346			ICPTL = $346
   205 = 0347			ICPTH = $347
   206 = 0348			ICBLL = $348
   207 = 0349			ICBLH = $349
   208 = 034A			ICAX1 = $34A
   209 = 034B			ICAX2 = $34B
   210
   211 = 03F8			BASICF  = $3f8
   212 = 03FA			GINTLK  = $3fa
   213
   214
   215 = 0230			SDLSTL	= $230	; display list address
   216 = 0200			VDSLST	= $200	; DLI address
   217
   218 = 0300			DDEVIC	= $300
   219 = 0301			DUNIT	= $301
   220 = 0302			DCOMND	= $302
   221 = 0303			DSTATS	= $303
   222 = 0304			DBUFLO	= $304
   223 = 0305			DBUFHI	= $305
   224
   225 = 030A			DAUX1	= $30A
   226 = 030B			DAUX2	= $30B
   227
   228
   229 = 0270			PADDL0	= 624	; 0-228 , shadow of POT0
   230 = 027C			PTRIG0	= 636	; 0 = PRESSED , shadow of PTRG0
   231 = 0278			STICK0	= 632	; 0000 = RLDU , shadow of PORTA
   232 = 0284			STRIG0	= 644	; 0 = PRESSED , shadow of TRIG0
   233
   234 = 0244			COLDST	= $244	; non zero --> do a cold start when pressing the reset key
   235
   236 				;----------------------------------------
   237 				; VBI:
   238 				;----------------------------------------
   239
   240 = E45C			SETVBV			= $E45C
   241 = E45F			XITVB_I			= $E45F
   242 = E45F			SYSVBV			= $E45F
   243 = E462			XITVB_D			= $E462
   244 = E462			XITVBV			= $E462
   245 = 0006			VBI_I			= 6
   246 = 0007			VBI_D			= 7
   247 = C0E2			NORMAL_VBI_I	= 49378
   248 = C28A			NORMAL_VBI_D	= 49802
   249 = 0222			VVBLKI			= 546
   250 = 0224			VVBLKD			= 548
   251 = E462			XITVB			= XITVB_D
   252
   253 				;----------------------------------------
   254 				; Handler vectors:
   255 				;----------------------------------------
   256
   257 = FFFA			NMIH_VECTOR		= 65530
   258 = FFFC			RESH_VECTOR		= 65532
   259 = FFFE			IRQH_VECTOR		= 65534
   260
   261 				;----------------------------------------
   262 				; I/O:
   263 				;----------------------------------------
   264
   265 = E453			DSKINV			= $E453 ; (58451)
   266 = E456			CIOV			= $E456	; (58454)
   267 = E459			SIOV			= $E459	; (58457)
   268
   269 				;----------------------------------------
   270 				; Restart routines
   271 				;----------------------------------------
   272
   273 = E474			WARMSV			= $E474
   274 = E477			COLDSV			= $E477
   275
   276 				;----------------------------------------
   277 				; Bit values:
   278 				;----------------------------------------
   279
   280 				; DMA values
   281 = 0020			DV_DMA_ON			= %00100000
   282 = 0010			DV_PM_ONE_LINE		= %00010000
   283 = 0008			DV_PLAYERS_ON		= %00001000
   284 = 0004			DV_MISSILES_ON		= %00000100
   285 = 0003			DV_WIDE_PF			= %00000011
   286 = 0002			DV_NORMAL_PF		= %00000010
   287 = 0001			DV_NARROW_PF		= %00000001
   288
   289 				; Display list values
   290 = 0080			DL_DLI_MASK		= %10000000
   291 = 0040			DL_LMS_MASK		= %01000000
   292 = 0020			DL_VSCROLL_MASK	= %00100000
   293 = 0010			DL_HSCROLL_MASK	= %00010000
   294
   295 = 0001			DL_JMP		= 1
   296 = 0041			DL_JVB		= 65
   297
   298 = 0000			DL_BLANK_1	= 0
   299 = 0010			DL_BLANK_2	= 16
   300 = 0020			DL_BLANK_3	= 32
   301 = 0030			DL_BLANK_4	= 48
   302 = 0040			DL_BLANK_5	= 64
   303 = 0050			DL_BLANK_6	= 80
   304 = 0060			DL_BLANK_7	= 96
   305 = 0070			DL_BLANK_8	= 112
   306
   307 				; Antic graphic modes
   308 = 0002			GM_CHAR_A2	= 2			; 2 colors, 40x24, 960b, 40xline, 8 scanlines
   309 = 0006			GM_CHAR_A6	= 6			; 4 colors, 20x24, 480b, 40xline, 8 scanlines
   310 = 0007			GM_CHAR_A7	= 7			; 4 colors, 20x12, 240b, 20xline, 16 scanlines
   311 = 0004			GM_CHAR_A4	= 4			; 5 colors, 40x24, 960b, 40xline, 8 scanlines
   312 = 0005			GM_CHAR_A5	= 5			; 5 colors, 40x12, 480b, 40xline, 16 scanlines
   313 = 0003			GM_CHAR_A3	= 3			; 2 colors, 40x24, 760b, 40xline, 10 scanlines
   314
   315 				; Basic graphic modes
   316 = 0002			GM_CHAR_G0	= 2			; 2 colors, 40x24, 960b, 40xline, 8 scanlines
   317 = 0006			GM_CHAR_G1	= 6			; 4 colors, 20x24, 480b, 40xline, 8 scanlines
   318 = 0007			GM_CHAR_G2	= 7			; 4 colors, 20x12, 240b, 20xline, 16 scanlines
   319 = 0004			GM_CHAR_G12	= 4			; 5 colors, 40x24, 960b, 40xline, 8 scanlines
   320 = 0005			GM_CHAR_G13	= 5			; 5 colors, 40x12, 480b, 40xline, 16 scanlines
   321
   322 = 0008			GM_PIXEL_G3	= 8			; 4 colors, 40x24, 240b, 10xline, 8 scanline
   323 = 0009			GM_PIXEL_G4	= 9			; 2 colors, 80x48, 480b, 10xline, 4 scanline
   324 = 000A			GM_PIXEL_G5	= 10		; 4 colors, 80x48, 960b, 20xline, 4 scanline
   325 = 000B			GM_PIXEL_G6	= 11		; 2 colors, 160x96, 1920b, 20xline, 2 scanline
   326 = 000D			GM_PIXEL_G7	= 13		; 4 colors, 160x96, 3840b, 40xline, 2 scanline
   327 = 000F			GM_PIXEL_G8	= 15		; 2 colors, 320x192, 7680b, 40xline, 1 scanline
   328 = 000C			GM_PIXEL_G14	= 12	; 2 colors, 160x192, 3840b, 20xline, 1 scanline
   329 = 000E			GM_PIXEL_G15	= 14	; 4 colors, 160x192, 7680b, 40xline, 1 scanline
   330
   331 = 000F			GM_PIXEL_G9	= 15		; 1 color, 80x192, 7680b, 40xline, 1 scanline
   332 = 000F			GM_PIXEL_G10	= 15	; 9 colors, 80x192, 7680b, 40xline, 1 scanline
   333 = 000F			GM_PIXEL_G11	= 15	; 16 colors, 80x192, 7680b, 40xline, 1 scanline
   334
   335 				; Prior values
   336 = 0001			PRV_PM_PRIORITY_1	= %00000001		; p0 p1 p2 p3 / pf0 pf1 pf2 pf3 (p5) / bk
   337 = 0002			PRV_PM_PRIORITY_2	= %00000010		; p0 p1 / pf0 pf1 pf2 pf3 (p5) / p2 p3 / bk
   338 = 0004			PRV_PM_PRIORITY_3	= %00000100		; pf0 pf1 pf2 pf3 (p5) /  p0 p1 p2 p3 / bk
   339 = 0008			PRV_PM_PRIORITY_4	= %00001000		; pf1 pf2 /  p0 p1 p2 p3 / pf0 pf3 (p5) / bk
   340 = 0010			PRV_FIFTH_PLAYER	= %00010000
   341 = 0020			PRV_PM_OVERLAP		= %00100000
   342 = 0040			PRV_GTIA_9			= %01000000
   343 = 0080			PRV_GTIA_10			= %10000000
   344 = 00C0			PRV_GTIA_11			= %11000000
   345
   346 				; Gractl values
   347 = 0001			GCTL_MISSILES		= %001
   348 = 0002			GCTL_PLAYERS		= %010
   349 = 0004			GCTL_LATCH_TRIGGERS	= %100
   350
   351 				; Consol values:
   352 = 0001			CNV_START_MASK		= %001
   353 = 0002			CNV_OPTION_MASK		= %010
   354 = 0004			CNV_SELECT_MASK		= %100
   355
   356 				; Stick values:
   357 = 0008			STV_RIGHT_MASK		= %1000
   358 = 0004			STV_LEFT_MASK		= %0100
   359 = 0002			STV_DOWN_MASK		= %0010
   360 = 0001			STV_UP_MASK			= %0001
   361
   362 = 0008			STICK_MASK_RIGHT	= %1000
   363 = 0004			STICK_MASK_LEFT		= %0100
   364 = 0002			STICK_MASK_DOWN		= %0010
   365 = 0001			STICK_MASK_UP		= %0001
   366
   367 = 0007			STICK_VALUE_RIGHT	= %0111
   368 = 000B			STICK_VALUE_LEFT	= %1011
   369 = 000D			STICK_VALUE_DOWN	= %1101
   370 = 000E			STICK_VALUE_UP		= %1110
   371
   372 				/*
   373 				KBCode Hexadecimal Values
   374 				 	$00	$01	$02	$03	$04	$05	$06	$07	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
   375 				$00	L	J	;	F1	F2	K	+	*	O	 	P	U	CR	I	-	=
   376 				$10	V	Hlp	C	F3	F4	B	X	Z	4	 	3	6	Esc	5	2	1
   377 				$20	,	Spc	.	N	 	M	/	Inv	R	 	E	Y	Tab	T	W	Q
   378 				$30	9	 	0	7	BS	8	<	>	F	H	D	 	Cap	G	S	A
   379
   380 				together with Shift Key: add +$40
   381 				together with Control key: add +$80 
   382 				*/
   382
    36 					icl "../../base/sys_macros.m65"
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65
     1 				;================================================================================
     2 				; System macros, Atari XL + mads [NRV 2009]
     3 				;================================================================================
     4
     5 				;--------------------------------------------------------------------------------
     6 				; SetVector [address] [word]
     7 				;--------------------------------------------------------------------------------
     8
     9 					.macro SetVector
    10 					   .if :0 <> 2
    11 					      .error "SetVector error"
    12 				
    13 					   .else
    14 					      lda #<:2
    15 					      sta :1
    16 					      lda #>:2
    17 					      sta :1+1
    18 					   .endif
    19 				
    20 					.endm
    21
    22
    23 				;--------------------------------------------------------------------------------
    24 				; SetColor [0..4] [0..255]
    25 				; SetColor [0..4] [0..15] [0..15]
    26 				;--------------------------------------------------------------------------------
    27
    28 					.macro SetColor
    29 					   .if :0 < 2 .or :0 > 3
    30 					      .error "SetColor error"
    31 				
    32 					   .else
    33 					      .if :0 = 2
    34 					          lda #:2
    35 					          sta COLPF0+:1
    36 					      .else
    37 					          lda #[:2 * 16 + :3]
    38 					          sta COLPF0+:1
    39 					      .endif
    40 					   .endif
    41 				
    42 					.endm
    43
    44
    45 				;--------------------------------------------------------------------------------
    46 				; SetPMColor [0..3] [0..255]
    47 				; SetPMColor [0..3] [0..15] [0..15]
    48 				;--------------------------------------------------------------------------------
    49
    50 					.macro SetPMColor
    51 					   .if :0 < 2 .or :0 > 3
    52 					      .error "SetPMColor error"
    53 				
    54 					   .else
    55 					      .if :0 = 2
    56 					          lda #:2
    57 					          sta COLPM0+:1
    58 					      .else
    59 					          lda #[:2 * 16 + :3]
    60 					          sta COLPM0+:1
    61 					      .endif
    62 					   .endif
    63 				
    64 					.endm
    65
    66
    67 				;--------------------------------------------------------------------------------
    68 				; VcountSync [0..130]
    69 				; (maximum limit is different on PAL: 155)
    70 				; (could wait forever if there are interrupts activated!)
    71 				; (or if some other "thread" uses "wsync")
    72 				;--------------------------------------------------------------------------------
    73
    74 					.macro VcountSync
    75 					   .if :0 <> 1
    76 					      .error "VcountSync error"
    77 				
    78 					   .else
    79 					      sta WSYNC
    80 				
    81 					      lda #:1
    82 				VSync1	 cmp VCOUNT
    83 					      bne VSync1
    84 				
    85 					      lda #:1+1
    86 				VSync2	 cmp VCOUNT
    87 					      bne VSync2
    88 				
    89 					      sta WSYNC
    90 					   .endif
    91 				
    92 					.endm
    93
    94
    95 				;--------------------------------------------------------------------------------
    96 				; VcountWait [0..130]
    97 				; (maximum limit is different on PAL: 155)
    98 				;--------------------------------------------------------------------------------
    99
   100 					.macro VcountWait
   101 					   .if :0 <> 1
   102 					      .error "VcountWait error"
   103 				
   104 					   .else
   105 					      lda #:1
   106 				VWait1	 cmp VCOUNT
   107 					      bne VWait1
   108 					   .endif
   109 				
   110 					.endm
   111
   112
   113 				;--------------------------------------------------------------------------------
   114 				; VcountWaitUntilEnter [0..129] [(p1+1)..130]
   115 				; (maximum limit is different on PAL: 155)
   116 				;--------------------------------------------------------------------------------
   117
   118 					.macro VcountWaitUntilEnter
   119 					   .if :0 <> 2 .or :1 >= :2
   120 					      .error "VcountWaitUntilEnter error"
   121 				
   122 					   .else
   123 				VWait1     lda VCOUNT
   124 						 cmp #:1
   125 						 beq VExit
   126 					      bcc VWait1	; VCOUNT < :1
   127 						 cmp #:2
   128 						 beq VExit
   129 					      bcs VWait1	; VCOUNT >= :2
   130 				VExit
   131 					   .endif
   132 				
   133 					.endm
   134
   135
   136 				;--------------------------------------------------------------------------------
   137 				; VcountWaitUntilExit [0..129] [(p1+1)..130]
   138 				; (maximum limit is different on PAL: 155)
   139 				;--------------------------------------------------------------------------------
   140
   141 					.macro VcountWaitUntilExit
   142 					   .if :0 <> 2 .or :1 >= :2
   143 					      .error "VcountWaitUntilExit error"
   144 				
   145 					   .else
   146 				VWait1     lda VCOUNT
   147 						 cmp #:1
   148 						 beq VWait1
   149 					      bcc VExit	; VCOUNT < :1
   150 						 cmp #:2
   151 					      bcc VWait1	; VCOUNT < :2
   152 						 beq VWait1
   153 				VExit
   154 					   .endif
   155 				
   156 					.endm
   157
   158
   159 				;--------------------------------------------------------------------------------
   160 				; MarkScanLine [0..255] [0..255]
   161 				; (mark the current scan line with a color)
   162 				;--------------------------------------------------------------------------------
   163
   164 					.macro MarkScanLine
   165 					   .if :0 <> 0 .and :0 <> 2
   166 					      .error "MarkScanLine error"
   167 				
   168 					   .else
   169 					  	   .if :0 = 0
   170 				  		      sta WSYNC
   171 				  	     	 lda #255		; mark color
   172 					  	      sta COLBK
   173 				
   174 				  		      sta WSYNC
   175 				  	     	 lda #0		; restore color
   176 					  	      sta COLBK
   177 				
   178 				  		   .else
   179 					     	 sta WSYNC
   180 						      lda #:1		; mark color
   181 						      sta COLBK
   182 				
   183 						      sta WSYNC
   184 						      lda #:2		; restore color
   185 					     	 sta COLBK
   186 						   .endif
   187 					   .endif
   188 				
   189 					.endm
   190
   191
   192 				;--------------------------------------------------------------------------------
   193 				; MarkScanLineIfConsol [0..255] [0..255]
   194 				; (mark the current scan line with a color, if a consol key is pressed)
   195 				;--------------------------------------------------------------------------------
   196
   197 					.macro MarkScanLineIfConsol
   198 					   .if :0 <> 0 .and :0 <> 2
   199 					      .error "MarkScanLineIfConsol error"
   200 				
   201 					   .else
   202 						 .if :0 = 0
   203 						      lda CONSOL
   204 						      and #%111
   205 					     	 cmp #%111
   206 						      beq ExitMarkScanLineIfConsol
   207 				
   208 						      sta WSYNC
   209 						      lda #255		; mark color
   210 						      sta COLBK
   211 				
   212 						      sta WSYNC
   213 						      lda #0		; restore color
   214 					     	 sta COLBK
   215 				
   216 					   	 .else
   217 						      lda CONSOL
   218 						      and #%111
   219 					     	 cmp #%111
   220 						      beq ExitMarkScanLineIfConsol
   221 				
   222 						      sta WSYNC
   223 					     	 lda #:1		; mark color
   224 						      sta COLBK
   225 				
   226 						      sta WSYNC
   227 					     	 lda #:2		; restore color
   228 						      sta COLBK
   229 				
   230 					   	 .endif
   231 					   .endif
   232 				
   233 				ExitMarkScanLineIfConsol
   234 				
   235 					.endm
   236
   237
   238 				;--------------------------------------------------------------------------------
   239 				; MarkCyclesIfConsol [0..255] [0..255]
   240 				; (mark the current scan position with a color, for some cycles)
   241 				;--------------------------------------------------------------------------------
   242
   243 					.macro MarkCyclesIfConsol
   244 					   .if :0 = 0
   245 					      lda CONSOL
   246 					      and #%111
   247 					      cmp #%111
   248 					      beq ExitMarkCyclesIfConsol
   249 				
   250 					      lda #255		; mark color
   251 					      sta COLBK
   252 				
   253 					      lda ($00),y	; dummy 5 cycles
   254 					      lda ($00),y	; dummy 5 cycles
   255 					      lda ($00),y	; dummy 5 cycles
   256 					      lda ($00),y	; dummy 5 cycles
   257 					      lda ($00),y	; dummy 5 cycles
   258 					      lda ($00),y	; dummy 5 cycles
   259 				
   260 					      lda #0		; restore color
   261 					      sta COLBK
   262 				
   263 					   .elseif :0 = 2
   264 					      lda CONSOL
   265 					      and #%111
   266 					      cmp #%111
   267 					      beq ExitMarkCyclesIfConsol
   268 				
   269 					      lda #:1		; mark color
   270 					      sta COLBK
   271 				
   272 					      lda ($00),y	; dummy 5 cycles
   273 					      lda ($00),y	; dummy 5 cycles
   274 					      lda ($00),y	; dummy 5 cycles
   275 					      lda ($00),y	; dummy 5 cycles
   276 					      lda ($00),y	; dummy 5 cycles
   277 					      lda ($00),y	; dummy 5 cycles
   278 				
   279 					      lda #:2		; restore color
   280 					      sta COLBK
   281 				
   282 					   .else
   283 					      .error "MarkCyclesIfConsol error"
   284 				
   285 					   .endif
   286 				
   287 				ExitMarkCyclesIfConsol
   288 				
   289 					.endm
   290
   291
   292 				;--------------------------------------------------------------------------------
   293 				; SetBasic [0,1]
   294 				;--------------------------------------------------------------------------------
   295
   296 					.macro SetBasic
   297 					   .if :0 <> 1
   298 					      .error "SetBasic error"
   299 				
   300 					   .else
   301 					      .if :1 = 0
   302 					         lda PORTB	; deactivate Basic
   303 					         ora #%00000010
   304 					         sta PORTB
   305 					      .else
   306 					         lda PORTB	; activate Basic
   307 					         and #%11111101
   308 					         sta PORTB
   309 					      .endif
   310 					   .endif
   311 				
   312 					.endm
   313
   314
   315 				;--------------------------------------------------------------------------------
   316 				; SetOperativeSystem [0,1]
   317 				;--------------------------------------------------------------------------------
   318
   319 					.macro SetOperativeSystem
   320 					   .if :0 <> 1
   321 					      .error "SetOperativeSystem error"
   322 				
   323 					   .else
   324 					      .if :1 = 0
   325 					         lda PORTB	; deactivate Operative System
   326 					         and #%11111110
   327 					         sta PORTB
   328 					      .else
   329 					         lda PORTB	; activate Operative System
   330 					         ora #%00000001
   331 					         sta PORTB
   332 					      .endif
   333 					   .endif
   334 				
   335 					.endm
   336
   337
   338 				;--------------------------------------------------------------------------------
   339 				; EnableBasic
   340 				;--------------------------------------------------------------------------------
   341
   342 					.macro EnableBasic
   343 					   .if :0 <> 0
   344 					      .error "EnableBasic error"
   345 				
   346 					   .else
   347 					      SetBasic 1
   348 					   .endif
   349 				
   350 					.endm
   351
   352
   353 				;--------------------------------------------------------------------------------
   354 				; DisableBasic
   355 				;--------------------------------------------------------------------------------
   356
   357 					.macro DisableBasic
   358 					   .if :0 <> 0
   359 					      .error "DisableBasic error"
   360 				
   361 					   .else
   362 					      SetBasic 0
   363 					   .endif
   364 				
   365 					.endm
   366
   367
   368 				;--------------------------------------------------------------------------------
   369 				; EnableOperativeSystem
   370 				;--------------------------------------------------------------------------------
   371
   372 					.macro EnableOperativeSystem
   373 					   .if :0 <> 0
   374 					      .error "EnableOperativeSystem error"
   375 				
   376 					   .else
   377 					      SetOperativeSystem 1
   378 					   .endif
   379 				
   380 					.endm
   381
   382
   383 				;--------------------------------------------------------------------------------
   384 				; DisableOperativeSystem
   385 				;--------------------------------------------------------------------------------
   386
   387 					.macro DisableOperativeSystem
   388 					   .if :0 <> 0
   389 					      .error "DisableOperativeSystem error"
   390 				
   391 					   .else
   392 					      SetOperativeSystem 0
   393 					   .endif
   394 				
   395 					.endm
   396
   397
   398 				;--------------------------------------------------------------------------------
   399 				; EnableNormalInterrupts
   400 				;--------------------------------------------------------------------------------
   401
   402 					.macro EnableNormalInterrupts
   403 					   .if :0 <> 0
   404 					      .error "EnableNormalInterrupts error"
   405 				
   406 					   .else
   407 					      cli
   408 				;	      lda #[8+16+32]	; serial I/O interrupts
   409 				;	      lda #[64+128]		; keyboard and break interrupts (only ones enabled on powerup)
   410 				;	      sta IRQEN
   411 					      lda #64			; VBI interrupt
   412 					      sta NMIEN
   413 					   .endif
   414 				
   415 					.endm
   416
   417
   418 				;--------------------------------------------------------------------------------
   419 				; DisableNormalInterrupts
   420 				;--------------------------------------------------------------------------------
   421
   422 					.macro DisableNormalInterrupts
   423 					   .if :0 <> 0
   424 					      .error "DisableNormalInterrupts error"
   425 				
   426 					   .else
   427 					      sei
   428 					      lda #0
   429 					      sta IRQEN
   430 					      sta NMIEN
   431 					   .endif
   432 				
   433 					.endm
   434
   435
   436 				;--------------------------------------------------------------------------------
   437 				; ClearSystem
   438 				;--------------------------------------------------------------------------------
   439
   440 					.macro ClearSystem
   441 					   .if :0 <> 0
   442 					      .error "ClearSystem error"
   443 				
   444 					   .else
   445 					      clc
   446 					      cld
   447 				
   448 					      sei
   449 				
   450 					      lda #0
   451 					      sta IRQEN	; clear interrupts and screen
   452 					      sta NMIEN
   453 				
   454 					      sta DMACTL
   455 					      sta COLBK
   456 				
   457 					      sta GRACTL	; clear P/M
   458 					      sta GRAFP0
   459 					      sta GRAFP1
   460 					      sta GRAFP2
   461 					      sta GRAFP3
   462 					      sta GRAFM
   463 				
   464 					      sta HPOSP0
   465 					      sta HPOSP1
   466 					      sta HPOSP2
   467 					      sta HPOSP3
   468 					      sta HPOSM0
   469 					      sta HPOSM1
   470 					      sta HPOSM2
   471 					      sta HPOSM3
   472 				
   473 					      sta PRIOR	; clear GTIA also
   474 				
   475 					      sta AUDCTL	; clear sound
   476 					      sta AUDC1
   477 					      sta AUDC2
   478 					      sta AUDC3
   479 					      sta AUDC4
   480 				
   481 					      lda #3
   482 					      sta SKCTL
   483 					   .endif
   484 				
   485 					.endm
   486
   487
   488 				;--------------------------------------------------------------------------------
   489 				; SetDisplayListAddress [word]
   490 				; (use when the screen is not being displayed!)
   491 				; (remember to not cross the 1K limit..)
   492 				;--------------------------------------------------------------------------------
   493
   494 					.macro SetDisplayListAddress
   495 					   .if :0 <> 1
   496 					      .error "SetDisplayListAddress error"
   497 				
   498 					   .else
   499 					      SetVector DLISTL, :1
   500 				
   501 				;	      lda #<:1
   502 				;	      sta DLISTL
   503 				;	      lda #>:1
   504 				;	      sta DLISTH
   505 					   .endif
   506 				
   507 					.endm
   508
   509
   510 				;--------------------------------------------------------------------------------
   511 				; SetFontAddress [word]
   512 				; (remember that this transform to a page a number)
   513 				;--------------------------------------------------------------------------------
   514
   515 					.macro SetFontAddress
   516 					   .if :0 <> 1
   517 					      .error "SetFontAddress error"
   518 				
   519 					   .else
   520 					      lda #>:1
   521 					      sta CHBASE
   522 					   .endif
   523 				
   524 					.endm
   525
   526
   527 				;--------------------------------------------------------------------------------
   528 				; SetPMBaseAddress [word]
   529 				; (remember that this transform to a page a number)
   530 				;--------------------------------------------------------------------------------
   531
   532 					.macro SetPMBaseAddress
   533 					   .if :0 <> 1
   534 					      .error "SetPMBaseAddress error"
   535 				
   536 					   .else
   537 					      lda #>:1
   538 					      sta PMBASE
   539 					   .endif
   540 				
   541 					.endm
   542
   543
   544 				;--------------------------------------------------------------------------------
   545 				; SetMemory [address] [bytes] [value]
   546 				;--------------------------------------------------------------------------------
   547
   548 				; warning, using some page zero memory
   549
   550 					.macro SetMemory
   551 				
   552 				setMemPtr	= 254
   553 				setMemCounter	= 252
   554 				
   555 					   .if :0 <> 3
   556 					      .error "SetMemory error"
   557 				
   558 					   .else
   559 					      ldy #0
   560 				
   561 					      lda #<:1
   562 					      sta setMemPtr
   563 					      lda #>:1
   564 					      sta setMemPtr+1
   565 				
   566 					      .if :2 < 256
   567 					         lda #:3
   568 				setMemLoop1
   569 					         sta (setMemPtr),y
   570 					         iny
   571 					         cpy #:2
   572 					         bne setMemLoop1
   573 				
   574 					      .else
   575 					         lda #<:2
   576 					         sta setMemCounter
   577 					         lda #>:2
   578 					         sta setMemCounter+1
   579 				
   580 				setMemLoop2
   581 					         lda #:3
   582 					         sta (setMemPtr),y
   583 					         iny
   584 					         bne setMemB1
   585 					         inc setMemPtr+1
   586 				setMemB1
   587 					         lda setMemCounter
   588 					         bne setMemB2
   589 					         dec setMemCounter+1
   590 				setMemB2
   591 					         dec setMemCounter
   592 				
   593 					         lda setMemCounter
   594 					         ora setMemCounter+1
   595 					         bne setMemLoop2
   596 					      .endif
   597 					   .endif
   598 				
   599 					.endm
   600
   601
   602 				;--------------------------------------------------------------------------------
   603 				; SetMemoryRandom [address] [bytes]
   604 				;--------------------------------------------------------------------------------
   605
   606 				; warning, using some page zero memory
   607
   608 					.macro SetMemoryRandom
   609 				
   610 				setMemRPtr	= 254
   611 				setMemRCounter	= 252
   612 				
   613 					   .if :0 <> 2
   614 					      .error "SetMemoryRandom error"
   615 				
   616 					   .else
   617 					      ldy #0
   618 				
   619 					      lda #<:1
   620 					      sta setMemRPtr
   621 					      lda #>:1
   622 					      sta setMemRPtr+1
   623 				
   624 					      .if :2 < 256
   625 				setMemRLoop1
   626 					         lda RANDOM
   627 					         sta (setMemRPtr),y
   628 					         iny
   629 					         cpy #:2
   630 					         bne setMemRLoop1
   631 				
   632 					      .else
   633 					         lda #<:2
   634 					         sta setMemRCounter
   635 					         lda #>:2
   636 					         sta setMemRCounter+1
   637 				
   638 				setMemRLoop2
   639 					         lda RANDOM
   640 					         sta (setMemRPtr),y
   641 					         iny
   642 					         bne setMemRB1
   643 					         inc setMemRPtr+1
   644 				setMemRB1
   645 					         lda setMemRCounter
   646 					         bne setMemRB2
   647 					         dec setMemRCounter+1
   648 				setMemRB2
   649 					         dec setMemRCounter
   650 				
   651 					         lda setMemRCounter
   652 					         ora setMemRCounter+1
   653 					         bne setMemRLoop2
   654 					      .endif
   655 					   .endif
   656 				
   657 					.endm
   658
   659
   660 				;--------------------------------------------------------------------------------
   661 				; ClampMemory [address] [bytes] [min value] [max value]
   662 				;--------------------------------------------------------------------------------
   663
   664 				; warning, using some page zero memory
   665
   666 					.macro ClampMemory
   667 				
   668 				clampMemPtr	= 254
   669 				clampMemCounter	= 252
   670 				
   671 					   .if :0 <> 4
   672 					      .error "ClampMemory error"
   673 				
   674 					   .else
   675 					      ldy #0
   676 				
   677 					      lda #<:1
   678 					      sta clampMemPtr
   679 					      lda #>:1
   680 					      sta clampMemPtr+1
   681 				
   682 					      .if :2 < 256
   683 				clampMemLoop1
   684 					         lda (clampMemPtr),y
   685 					         cmp #:3
   686 					         bcs clampMemB3		; if >= min then continue
   687 					         lda #:3
   688 					         jmp clampMemB4
   689 				clampMemB3
   690 					         cmp #:4
   691 					         bcc clampMemB4		; if < max then continue
   692 				;	         beq clampMemB4		; if = max then continue
   693 					         lda #:4
   694 				clampMemB4
   695 					         sta (clampMemPtr),y
   696 				
   697 					         iny
   698 					         cpy #:2
   699 					         bne clampMemLoop1
   700 				
   701 					      .else
   702 					         lda #<:2
   703 					         sta clampMemCounter
   704 					         lda #>:2
   705 					         sta clampMemCounter+1
   706 				
   707 				clampMemLoop2
   708 					         lda (clampMemPtr),y
   709 					         cmp #:3
   710 					         bcs clampMemB5		; if >= min then continue
   711 					         lda #:3
   712 					         jmp clampMemB6
   713 				clampMemB5
   714 					         cmp #:4
   715 					         bcc clampMemB6		; if < max then continue
   716 				;	         beq clampMemB6		; if = max then continue
   717 					         lda #:4
   718 				clampMemB6
   719 					         sta (clampMemPtr),y
   720 				
   721 					         iny
   722 					         bne clampMemB1
   723 					         inc clampMemPtr+1
   724 				clampMemB1
   725 					         lda clampMemCounter
   726 					         bne clampMemB2
   727 					         dec clampMemCounter+1
   728 				clampMemB2
   729 					         dec clampMemCounter
   730 				
   731 					         lda clampMemCounter
   732 					         ora clampMemCounter+1
   733 					         bne clampMemLoop2
   734 					      .endif
   735 					   .endif
   736 				
   737 					.endm
   738
   739
   740 				;--------------------------------------------------------------------------------
   741 				; AndMemory [address] [bytes] [value]
   742 				;--------------------------------------------------------------------------------
   743
   744 				; warning, using some page zero memory
   745
   746 					.macro AndMemory
   747 				
   748 				andMemPtr	= 254
   749 				andMemCounter	= 252
   750 				
   751 					   .if :0 <> 3
   752 					      .error "AndMemory error"
   753 				
   754 					   .else
   755 					      ldy #0
   756 				
   757 					      lda #<:1
   758 					      sta andMemPtr
   759 					      lda #>:1
   760 					      sta andMemPtr+1
   761 				
   762 					      .if :2 < 256
   763 				andMemLoop1
   764 					         lda (andMemPtr),y
   765 					         and #:3
   766 					         sta (andMemPtr),y
   767 					         iny
   768 					         cpy #:2
   769 					         bne andMemLoop1
   770 				
   771 					      .else
   772 					         lda #<:2
   773 					         sta andMemCounter
   774 					         lda #>:2
   775 					         sta andMemCounter+1
   776 				
   777 				andMemLoop2
   778 					         lda (andMemPtr),y
   779 					         and #:3
   780 					         sta (andMemPtr),y
   781 					         iny
   782 					         bne andMemB1
   783 					         inc andMemPtr+1
   784 				andMemB1
   785 					         lda andMemCounter
   786 					         bne andMemB2
   787 					         dec andMemCounter+1
   788 				andMemB2
   789 					         dec andMemCounter
   790 				
   791 					         lda andMemCounter
   792 					         ora andMemCounter+1
   793 					         bne andMemLoop2
   794 					      .endif
   795 					   .endif
   796 				
   797 					.endm
   798
   799
   800 				;--------------------------------------------------------------------------------
   801 				; CopyMemory [source address] [dest address] [bytes]
   802 				;--------------------------------------------------------------------------------
   803
   804 				; warning, using some page zero memory
   805
   806 					.macro CopyMemory
   807 				
   808 				copyMemPtr1	= 254
   809 				copyMemPtr2	= 252
   810 				copyMemCounter	= 250
   811 				
   812 					   .if :0 <> 3
   813 					      .error "CopyMemory error"
   814 				
   815 					   .else
   816 					      ldy #0
   817 				
   818 					      .if :3 <= 256
   819 				copyMemLoop1
   820 						lda :1,y
   821 						sta :2,y
   822 						iny
   823 						.if :3 < 256
   824 							cpy #<:3
   825 						.endif
   826 						bne copyMemLoop1
   827 				
   828 					      .else
   829 					        lda #<:1
   830 					        sta copyMemPtr1
   831 					        lda #>:1
   832 					        sta copyMemPtr1+1
   833 						lda #<:2
   834 						sta copyMemPtr2
   835 						lda #>:2
   836 						sta copyMemPtr2+1
   837 						lda #<:3
   838 						sta copyMemCounter
   839 						lda #>:3
   840 						sta copyMemCounter+1
   841 				
   842 				copyMemLoop2
   843 						lda (copyMemPtr1),y
   844 						sta (copyMemPtr2),y
   845 						iny
   846 						bne copyMemB1
   847 						inc copyMemPtr1+1
   848 						inc copyMemPtr2+1
   849 				copyMemB1
   850 						lda copyMemCounter
   851 						bne copyMemB2
   852 						dec copyMemCounter+1
   853 				copyMemB2
   854 						dec copyMemCounter
   855 				
   856 						lda copyMemCounter
   857 						ora copyMemCounter+1
   858 						bne copyMemLoop2
   859 					      .endif
   860 					   .endif
   861 				
   862 					.endm
   863
   864
   865 				;--------------------------------------------------------------------------------
   866 				; CreateDisplayList [DL address] [DL mode] [memory address]
   867 				; (remember to not cross the 1K limit.. and the 4K limit)
   868 				;--------------------------------------------------------------------------------
   869
   870 				; 	.macro CreateDisplayList
   871 				; 	   .if :0 <> 3
   872 				; 	      .error "CreateDisplayList error"
   873 				; 
   874 				; 	   .else
   875 				; 
   876 				; 	   .endif
   877 				; 
   878 				; 	.endm
   879
   880
   881 				;--------------------------------------------------------------------------------
   882 				;
   883 				;--------------------------------------------------------------------------------
   884
   885
   886
    37 					
    38 				// Now a cart type definition
    39
    40 				//Cartridge types available
    41 				// 1: Atarimax 8 Mbit
    42 				// 2: Switchable XEGS 8 Mbit
    43 				// 3: Atarimax 1 Mbit
    44 				// 4: Atrax 128 Kbytes (1 Mbit)
    45 				// 5: Megacart 128 KB
    46 				// 6: Megacart 1024 KB
    47
    48 = 0001			TYPE_CART =1
    49
    50 				.if TYPE_CART = 1 
    51 = A000				start_cartridge = $A000
    52 = C000				end_bank = $C000
    53 = 0080				cart_banks = 128
    54 = D5FF				cart_apaga = $D5FF
    55 = 0000				FLAG_16KB = $00
    56 				.elseif TYPE_CART = 2
    57 					start_cartridge = $8000
    58 					end_bank = $A000
    59 					cart_banks = 128
    60 					cart_apaga = $D5FF
    61 					FLAG_16KB = $00
    62 				.elseif TYPE_CART = 3
    63 					start_cartridge = $A000
    64 					end_bank = $C000
    65 					cart_banks = 16
    66 					cart_apaga = $D51F
    67 					FLAG_16KB = $00
    68 				.elseif TYPE_CART = 4
    69 					start_cartridge = $A000
    70 					end_bank = $C000
    71 					cart_banks = 16
    72 					cart_apaga = $D5FF
    73 					FLAG_16KB = $00
    74 				.elseif TYPE_CART = 5
    75 					start_cartridge = $8000
    76 					end_bank = $C000
    77 					cart_banks = 8
    78 					cart_apaga = $D5FF
    79 					FLAG_16KB = $01
    80 				.elseif TYPE_CART = 6
    81 					start_cartridge = $8000
    82 					end_bank = $C000
    83 					cart_banks = 64
    84 					cart_apaga = $D5FF
    85 					FLAG_16KB = $01
    86 				.else
    87 					.error "Cartridge type not defined"
    88 				.endif
    89
    90 				//Parameters to init the loader
    91
    92 = 0400			start_loader = $0400
    93 = CC00			start_loader2 = $cc00		//Dungeon loader.
    94 = CD00			start_cart_io =$cd00		//Cartridge IO routines.
    95 = 0480			start_init2 = $480
    96 = 0100			start_exit = $100
    97
    98 				// Page zero parameters
    99 = 0032			BUFRLO 	= $32
   100 = 0033			BUFRHI 	= $33
   101 = 0034			AUX1	= $34
   102 = 0035			AUX2	= $35
   103 = 0036			c_bank	= $36
   104
   105 				//Starting the cartridge
   106
   107 					org start_cartridge
   108 A000				lmb #$00	//BANK 0
   109
   110 				// First, copy the loader routine and get back to the OS. You can do whatever you want to initialize.
   111 				Copy_init
   112 				.proc init
   113 				// 1st stage: checks OPTION and puts the first disk loader into memory.
   114 A000 A9 FF 8D 01 D3		mva #$ff portb
   115 A005 A9 01 8D F8 03		mva #$01 basicf
   116 A00A AD 1F D0			lda consol
   117 A00D 29 04			and #$04	//OPTION??
   118 A00F D0 10			bne NO_OPTION	//NO!
   119 A011				CopyMemory Copy_Exit,start_exit,(.len Exit)
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A011 A0 00			      ldy #0
    13 A013			copyMemLoop1
    14 A013 B9 30 A2				lda COPY_EXIT,y
    15 A016 99 00 01				sta START_EXIT,y
    16 A019 C8					iny
    18 A01A C0 20					cpy #<(.LEN EXIT)
    20 A01C D0 F5				bne copyMemLoop1
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   120 A01E 4C 00 01			jmp exit
   121 A021			NO_OPTION
   122 A021 18				clc
   123 A022 60				rts
   124 				.endp
   125 A023			.proc init1
   126 A023				CopyMemory Copy_loader, start_loader,(.len loader)	//Copy loader to the desired address in the parameters.
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A023 A0 00			      ldy #0
    13 A025			copyMemLoop1
    14 A025 B9 78 A3				lda COPY_LOADER,y
    15 A028 99 00 04				sta START_LOADER,y
    16 A02B C8					iny
    18 A02C C0 67					cpy #<(.LEN LOADER)
    20 A02E D0 F5				bne copyMemLoop1
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   127 A030 A9 00 8D 53 04		mva #$00 loader.flag	//Avoid turning the cartridge off
   128 A035 A9 00 8D 04 03 A9 + 	mwa #$600 dbuflo	
   129 A03F A9 01 8D 0A 03 A9 + 	mwa #$01  daux1
   130 A049 A9 52 8D 02 03		mva #$52  dcomnd
   131 A04E 20 00 04			jsr loader		//Read 1st sector
   132 A051 A9 00 8D 33 06 A9 + 	mwa #loader $633	//Patch SIO call
   133 A05B A9 6D 8D 3E 06 A9 + 	mwa #cont $63e		//Patch final instruction
   134 A065 A9 70 8D 2E 06		mva #$70 $62e		//Patch address for DL.
   135 A06A 4C 06 06			jmp $606
   136 A06D			cont
   137 A06D A9 70			lda #$70
   138 A06F 8D 05 70			sta $7005	//Rellocating credits screen from $b000 to $7000
   139 A072 8D 19 70			sta $7019	
   140 A075 8D 20 70			sta $7020
   141 A078 8D 3F 70			sta $703f
   142 A07B 8D 7E 70			sta $707e
   143 A07E A9 7D			lda #$7d
   144 A080 8D 0F 70			sta $700f
   145 A083 8D 67 70			sta $7067	//Done!
   146 A086 A9 00 8D 46 70 A9 + 	mwa #loader $7046	//Patch SIO call
   147
   148 A090 A9 00 8D 01 70 A9 + 	mwa #$600 $7001		//Patching "ahoy!" message so it doesn't appear somewhere else.
   149 A09A A9 4C 8D 24 70		mva #$4c $7024		//Once loaded the screen, go to 'CONT2'
   150 A09F A9 AC 8D 25 70 A9 + 	mwa #cont2 $7025	//Done!
   151 A0A9 4C 00 70			jmp $7000		//Go credits screen!
   152 A0AC			cont2
   153 A0AC A9 FF 8D 53 04		mva #$ff loader.flag	//Resume turning the cartridge off after reading the cartridge
   154 A0B1				CopyMemory Copy_init2, init2, (.len init2)		//Copy second init routine if necessary.
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A0B1 A0 00			      ldy #0
    23 A0B3 A9 50			        lda #<COPY_INIT2
    24 A0B5 85 FE			        sta copyMemPtr1
    25 A0B7 A9 A2			        lda #>COPY_INIT2
    26 A0B9 85 FF			        sta copyMemPtr1+1
    27 A0BB A9 80				lda #<INIT2
    28 A0BD 85 FC				sta copyMemPtr2
    29 A0BF A9 04				lda #>INIT2
    30 A0C1 85 FD				sta copyMemPtr2+1
    31 A0C3 A9 28				lda #<(.LEN INIT2)
    32 A0C5 85 FA				sta copyMemCounter
    33 A0C7 A9 01				lda #>(.LEN INIT2)
    34 A0C9 85 FB				sta copyMemCounter+1
    36 A0CB			copyMemLoop2
    37 A0CB B1 FE				lda (copyMemPtr1),y
    38 A0CD 91 FC				sta (copyMemPtr2),y
    39 A0CF C8					iny
    40 A0D0 D0 04				bne copyMemB1
    41 A0D2 E6 FF				inc copyMemPtr1+1
    42 A0D4 E6 FD				inc copyMemPtr2+1
    43 A0D6			copyMemB1
    44 A0D6 A5 FA				lda copyMemCounter
    45 A0D8 D0 02				bne copyMemB2
    46 A0DA C6 FB				dec copyMemCounter+1
    47 A0DC			copyMemB2
    48 A0DC C6 FA				dec copyMemCounter
    50 A0DE A5 FA				lda copyMemCounter
    51 A0E0 05 FB				ora copyMemCounter+1
    52 A0E2 D0 E7				bne copyMemLoop2
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   155 A0E4 A9 00 8D 63 70		mva #$00 $7063
   156 A0E9 8D 68 70			sta $7068
   157 A0EC A9 60 8D 64 70		mva #$60 $7064
   158 A0F1 8D 69 70			sta $7069
   159 A0F4				CopyMemory init2.dl_patch,$707b, (init2.dl_end-init2.dl_patch+1)
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A0F4 A0 00			      ldy #0
    13 A0F6			copyMemLoop1
    14 A0F6 B9 50 05				lda INIT2.DL_PATCH,y
    15 A0F9 99 7B 70				sta $707B,y
    16 A0FC C8					iny
    18 A0FD C0 09					cpy #<(INIT2.DL_END-INIT2.DL_PATCH+1)
    20 A0FF D0 F5				bne copyMemLoop1
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   160 A101 A5 14			lda rtclock
   161 A103 C5 14		loop0	cmp rtclock
   162 A105 F0 FC			beq loop0
   163
   164
   165 A107				CopyMemory $c000,$800,$1000				//Copy OS to RAM
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A107 A0 00			      ldy #0
    23 A109 A9 00			        lda #<$C000
    24 A10B 85 FE			        sta copyMemPtr1
    25 A10D A9 C0			        lda #>$C000
    26 A10F 85 FF			        sta copyMemPtr1+1
    27 A111 A9 00				lda #<$800
    28 A113 85 FC				sta copyMemPtr2
    29 A115 A9 08				lda #>$800
    30 A117 85 FD				sta copyMemPtr2+1
    31 A119 A9 00				lda #<$1000
    32 A11B 85 FA				sta copyMemCounter
    33 A11D A9 10				lda #>$1000
    34 A11F 85 FB				sta copyMemCounter+1
    36 A121			copyMemLoop2
    37 A121 B1 FE				lda (copyMemPtr1),y
    38 A123 91 FC				sta (copyMemPtr2),y
    39 A125 C8					iny
    40 A126 D0 04				bne copyMemB1
    41 A128 E6 FF				inc copyMemPtr1+1
    42 A12A E6 FD				inc copyMemPtr2+1
    43 A12C			copyMemB1
    44 A12C A5 FA				lda copyMemCounter
    45 A12E D0 02				bne copyMemB2
    46 A130 C6 FB				dec copyMemCounter+1
    47 A132			copyMemB2
    48 A132 C6 FA				dec copyMemCounter
    50 A134 A5 FA				lda copyMemCounter
    51 A136 05 FB				ora copyMemCounter+1
    52 A138 D0 E7				bne copyMemLoop2
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   166 A13A				CopyMemory $d800,$1800,$2800
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A13A A0 00			      ldy #0
    23 A13C A9 00			        lda #<$D800
    24 A13E 85 FE			        sta copyMemPtr1
    25 A140 A9 D8			        lda #>$D800
    26 A142 85 FF			        sta copyMemPtr1+1
    27 A144 A9 00				lda #<$1800
    28 A146 85 FC				sta copyMemPtr2
    29 A148 A9 18				lda #>$1800
    30 A14A 85 FD				sta copyMemPtr2+1
    31 A14C A9 00				lda #<$2800
    32 A14E 85 FA				sta copyMemCounter
    33 A150 A9 28				lda #>$2800
    34 A152 85 FB				sta copyMemCounter+1
    36 A154			copyMemLoop2
    37 A154 B1 FE				lda (copyMemPtr1),y
    38 A156 91 FC				sta (copyMemPtr2),y
    39 A158 C8					iny
    40 A159 D0 04				bne copyMemB1
    41 A15B E6 FF				inc copyMemPtr1+1
    42 A15D E6 FD				inc copyMemPtr2+1
    43 A15F			copyMemB1
    44 A15F A5 FA				lda copyMemCounter
    45 A161 D0 02				bne copyMemB2
    46 A163 C6 FB				dec copyMemCounter+1
    47 A165			copyMemB2
    48 A165 C6 FA				dec copyMemCounter
    50 A167 A5 FA				lda copyMemCounter
    51 A169 05 FB				ora copyMemCounter+1
    52 A16B D0 E7				bne copyMemLoop2
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   167 A16D A9 20			lda #$20						//Avoid flashing screen!
   168 A16F 8D F4 02			sta chbas						//while copying OS to RAM.
   169 A172 8D 09 D4			sta chbase						//Done!
   170 A175 A5 14			lda rtclock						//Wait 1 frame
   171 A177 C5 14		loop1	cmp rtclock
   172 A179 F0 FC			beq loop1						//Done!
   173
   174 A17B 78				sei
   175 A17C A9 00 8D 0E D4		mva #$00 nmien						//disabling IRQs, NMIs
   176 A181 A9 FE 8D 01 D3		mva #$fe portb						//Enabling upper RAM.
   177 A186				CopyMemory $800,$c000,$1000				//Put OS on upper RAM
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A186 A0 00			      ldy #0
    23 A188 A9 00			        lda #<$800
    24 A18A 85 FE			        sta copyMemPtr1
    25 A18C A9 08			        lda #>$800
    26 A18E 85 FF			        sta copyMemPtr1+1
    27 A190 A9 00				lda #<$C000
    28 A192 85 FC				sta copyMemPtr2
    29 A194 A9 C0				lda #>$C000
    30 A196 85 FD				sta copyMemPtr2+1
    31 A198 A9 00				lda #<$1000
    32 A19A 85 FA				sta copyMemCounter
    33 A19C A9 10				lda #>$1000
    34 A19E 85 FB				sta copyMemCounter+1
    36 A1A0			copyMemLoop2
    37 A1A0 B1 FE				lda (copyMemPtr1),y
    38 A1A2 91 FC				sta (copyMemPtr2),y
    39 A1A4 C8					iny
    40 A1A5 D0 04				bne copyMemB1
    41 A1A7 E6 FF				inc copyMemPtr1+1
    42 A1A9 E6 FD				inc copyMemPtr2+1
    43 A1AB			copyMemB1
    44 A1AB A5 FA				lda copyMemCounter
    45 A1AD D0 02				bne copyMemB2
    46 A1AF C6 FB				dec copyMemCounter+1
    47 A1B1			copyMemB2
    48 A1B1 C6 FA				dec copyMemCounter
    50 A1B3 A5 FA				lda copyMemCounter
    51 A1B5 05 FB				ora copyMemCounter+1
    52 A1B7 D0 E7				bne copyMemLoop2
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   178 A1B9				CopyMemory $1800,$d800,$2800
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A1B9 A0 00			      ldy #0
    23 A1BB A9 00			        lda #<$1800
    24 A1BD 85 FE			        sta copyMemPtr1
    25 A1BF A9 18			        lda #>$1800
    26 A1C1 85 FF			        sta copyMemPtr1+1
    27 A1C3 A9 00				lda #<$D800
    28 A1C5 85 FC				sta copyMemPtr2
    29 A1C7 A9 D8				lda #>$D800
    30 A1C9 85 FD				sta copyMemPtr2+1
    31 A1CB A9 00				lda #<$2800
    32 A1CD 85 FA				sta copyMemCounter
    33 A1CF A9 28				lda #>$2800
    34 A1D1 85 FB				sta copyMemCounter+1
    36 A1D3			copyMemLoop2
    37 A1D3 B1 FE				lda (copyMemPtr1),y
    38 A1D5 91 FC				sta (copyMemPtr2),y
    39 A1D7 C8					iny
    40 A1D8 D0 04				bne copyMemB1
    41 A1DA E6 FF				inc copyMemPtr1+1
    42 A1DC E6 FD				inc copyMemPtr2+1
    43 A1DE			copyMemB1
    44 A1DE A5 FA				lda copyMemCounter
    45 A1E0 D0 02				bne copyMemB2
    46 A1E2 C6 FB				dec copyMemCounter+1
    47 A1E4			copyMemB2
    48 A1E4 C6 FA				dec copyMemCounter
    50 A1E6 A5 FA				lda copyMemCounter
    51 A1E8 05 FB				ora copyMemCounter+1
    52 A1EA D0 E7				bne copyMemLoop2
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   179 A1EC A9 E0			lda #$e0						//Restore font to original address
   180 A1EE 8D F4 02			sta chbas
   181 A1F1 8D 09 D4			sta chbase
   182 A1F4 A9 40 8D 0E D4		mva #$40 nmien						//Restore NMIs
   183 A1F9				CopyMemory Copy_loader2, start_loader2,(.len loader2)
Macro: COPYMEMORY [Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\..\..\base\sys_macros.m65]
     2 = 00FE			copyMemPtr1	= 254
     3 = 00FC			copyMemPtr2	= 252
     4 = 00FA			copyMemCounter	= 250
    10 A1F9 A0 00			      ldy #0
    23 A1FB A9 DF			        lda #<COPY_LOADER2
    24 A1FD 85 FE			        sta copyMemPtr1
    25 A1FF A9 A3			        lda #>COPY_LOADER2
    26 A201 85 FF			        sta copyMemPtr1+1
    27 A203 A9 00				lda #<START_LOADER2
    28 A205 85 FC				sta copyMemPtr2
    29 A207 A9 CC				lda #>START_LOADER2
    30 A209 85 FD				sta copyMemPtr2+1
    31 A20B A9 78				lda #<(.LEN LOADER2)
    32 A20D 85 FA				sta copyMemCounter
    33 A20F A9 03				lda #>(.LEN LOADER2)
    34 A211 85 FB				sta copyMemCounter+1
    36 A213			copyMemLoop2
    37 A213 B1 FE				lda (copyMemPtr1),y
    38 A215 91 FC				sta (copyMemPtr2),y
    39 A217 C8					iny
    40 A218 D0 04				bne copyMemB1
    41 A21A E6 FF				inc copyMemPtr1+1
    42 A21C E6 FD				inc copyMemPtr2+1
    43 A21E			copyMemB1
    44 A21E A5 FA				lda copyMemCounter
    45 A220 D0 02				bne copyMemB2
    46 A222 C6 FB				dec copyMemCounter+1
    47 A224			copyMemB2
    48 A224 C6 FA				dec copyMemCounter
    50 A226 A5 FA				lda copyMemCounter
    51 A228 05 FB				ora copyMemCounter+1
    52 A22A D0 E7				bne copyMemLoop2
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   184 A22C 58				cli							//Restore IRQs
   185 A22D 4C 80 04			jmp init2						//Go to second part!
   186 				.endp
   187 A230			Copy_exit		//exit to boot routine.
   188 A230			.proc exit, start_exit
   189 0100 78				sei
   190 0101 A9 00			lda #$00
   191 0103 8D 0E D4			sta nmien	//disable NMIs
   192 0106 A9 FF			lda #$ff
   193 0108 8D F8 03			sta basicf	//Turn basic off
   194 010B 8D FF D5			sta cart_apaga	//Turn cartridge off
   195 010E AD 13 D0			lda trig3
   196 0111 8D FA 03			sta gintlk	//Avoid the computer to hang up.
   197 0114 A9 40			lda #$40
   198 0116 8D 0E D4			sta nmien	//Restoring NMIs
   199 0119 A9 01			lda #$01
   200 011B 8D FD BF			sta $BFFD	//Boot disk! It's a trick to not to use illegal routines
   201 011E 58				cli		//Restore IRQs
   202 011F 60				rts		//Go to BOOT!
   203 				.endp
   204
   205 A250			Copy_init2
   206 A250			.proc init2, start_init2
   207 0480 78				sei			//Turn IRQs off
   208 0481 A9 00 8D 0E D4		mva #$00 nmien		//Turn NMIs off
   209 0486 A2 FF			ldx #$ff
   210 0488 9A				txs			//Reset stack pointer.
   211 0489 8E FF D5			stx cart_apaga		//Turn the cartridge off.
   212 048C AD 13 D0 8D FA 03		mva trig3 gintlk	//Avoid hanging up
   213 0492 A9 40 8D 0E D4		mva #$40 nmien		//Restore NMIs
   214 0497 58				cli			//Restore IRQs
   215 					
   216 0498 A9 A5 8D 41 70 A9 + 	mwa #cont2 $7041	//Patch final instruction
   217 04A2 4C 2A 70			jmp $702A		//GO!
   218 04A5			cont2
   219 04A5 A9 22			lda #$22
   220 04A7 8D 2F 02			sta sdmctl
   221 04AA 8D 00 D4			sta dmactl		//Turn screen on
   222 04AD A9 00 8D 43 1E A9 + 	mwa #loader $1e43	//Patch SIO call 1
   223 04B7 A9 00 8D 7D 1E A9 + 	mwa #loader $1e7d	//Patch SIO call 2
   224 04C1 A9 FF 8D 7A 1E A9 + 	mwa #cont3 $1e7a	//Patch final instruction
   225 04CB A9 01			lda #$01			//Put exclamation mark
   226 04CD 8D A7 05			sta dl_text_mark	//on screen!
   227 04D0 A5 14			lda rtclock
   228 04D2 18				clc
   229 04D3 A6 62			ldx palnts			//Is it PAL?
   230 04D5 D0 02			bne cont2_pal		//Yes, 150 frames to add
   231 04D7 69 1E			adc #30				//NTSC, 180 frames to add
   232 04D9			cont2_pal
   233 04D9 69 96			adc #150
   234 04DB			cont2_loop
   235 04DB C5 14			cmp rtclock			//Done the time?
   236 04DD F0 1C			beq cont2_intro		//Yes, go to intro!
   237 04DF 8D FE 04			sta save_a			//Save temporarily
   238 04E2 AD 1F D0			lda consol			//Load consol keys
   239 04E5 49 07			eor #$07			//Is anyone pressed?
   240 04E7 D0 12			bne cont2_intro		//Yes! Go to intro.
   241 04E9 AD 84 02			lda strig0			//Is joystick button pressed?
   242 04EC F0 0D			beq cont2_intro		//Yes! Go to intro.
   243 04EE AD FC 02			lda ch				//Load keyboard.
   244 04F1 C9 FF			cmp #$ff			//Any key pressed?
   245 04F3 D0 06			bne cont2_intro		//Yes! Go to intro.
   246 04F5 AD FE 04			lda save_a			//Recover A
   247 04F8 4C DB 04			jmp cont2_loop		//Continue the loop until 3 seconds
   248 04FB			cont2_intro	
   249 04FB 4C 00 20			jmp $2000		//Execute intro!!
   250 04FE			save_a
   251 04FE 00				.by $00
   252 04FF			cont3
   253 04FF A9 20			lda #$20		//NO "48K" display!!
   254 0501 8D 8F 81			sta $818f
   255 0504 8D 90 81			sta $8190
   256 0507 8D 91 81			sta $8191		//Done!
   257 050A A9 4C 8D A4 81		mva #$4c $81a4		//Skip
   258 050F A9 21 8D A5 81 A9 + 	mwa #$8221 $81a5	//RAM size detection, Force 48K RAM.
   259
   260 				//TO DO: patch custom SIO command to $CC00
   261 				//What to know:
   262 				//	$230 = SIO drive ID ($31-$34)
   263 				//	$231 = SIO command ($52 read, $53 status, $50 put, $22 format)
   264 				//	$232 = SIO aux1 (sector number lo byte)
   265 				//	$233 = SIO aux2 (sector number hi byte)
   266
   267 0519 A9 00 8D A1 24 A9 + 	mwa #loader2 $24a1
   268 0523 A9 00 8D E1 80		mva #$00 $80e1		//Just detect D1: We won't use D2:,D3: or D4:
   269 				//	lda #$4c		//NOPs to force detection on D1:
   270 				//	sta $80e0
   271 				//	mwa #$810d $80e1
   272 0528 A9 EA			lda #$ea		//Store NOPs
   273 052A 8D 93 28			sta $2893		//Forces no checksum
   274 052D 8D 94 28			sta $2894		//Forces no checksum
   275 0530 8D 8B 28			sta $288b		//Forces no checksum
   276 0533 8D 8C 28			sta $288c		//Forces no checksum
   277 0536 8D 0B 81			sta $810b
   278 0539 8D 0C 81			sta $810c		//Don't check D1: a second time.
   279 053C A2 00			ldx #$00
   280 053E 8E 4F 02			stx $24f		//Virtual D2: enabled!	
   281 0541 8E 51 02			stx $251		//Virtual D4: enabled!
   282 0544 CA				dex
   283 0545 8E 50 02			stx $250		//D3: disabled 
   284 0548 A9 34 8D 0E 81		mva #$34 $810e		//Use D4: as main drive
   285 054D 4C 7E 80			jmp $807e		//Go to the game!
   286
   287 0550			dl_patch
   288 0550 70 42			.by $70,$42
   289 0552 58 05			.word dl_text
   290 0554 02				.by $02
   291 0555 41				.by $41
   292 0556 60 70			.word $7060
   293 0558			dl_end
   294 0558			dl_text
   295 0558 00 00 00 00 00 00 + 	.sb "        Cartridge conversion 2020       "
   296 0580 00 00 00 27 75 69 + 	.sb "   Guillermo Fuenzalida & Mark Keates  "
   297 05A7			dl_text_mark
   298 05A7 00				.sb " "
   299 				.endp
   300
   301 A378			Copy_init3
   302
   303 				// Now, we put the loader
   304 A378			Copy_Loader
   305 A378			.proc	loader , start_loader
   306 0400 78				sei		// No IRQs!
   307 0401 A9 00			lda #$00	
   308 0403 8D 0E D4			sta nmien	// No NMIs!
   309 0406 AD 04 03			lda dbuflo	// Take LSB of the address to store
   310 0409 85 32			sta bufrlo	// Store it on Page Zero!
   311 040B AD 05 03			lda dbufhi	// Take MSB of the addres to store
   312 040E 85 33			sta bufrhi	// Store it!
   313 0410 38				sec		// Let's substract 1
   314 0411 AD 0A 03			lda daux1	// To the sector number!
   315 0414 E9 01			sbc #$01
   316 0416 85 34			sta aux1	// Store it!
   317 0418 AD 0B 03			lda daux2	// Take MSB of the sector to read
   318 041B E9 00			sbc #$00	// Make sure we store it
   319 041D 85 35			sta aux2	// on page zero!
   320 041F 18				clc		// Clear the carry.
   321 0420 A5 34			lda aux1	// Take new sector number
   322 0422 48				pha		// save it!
   323 					.if FLAG_16KB = 0
   324 0423 29 C0				and #$c0	// Take bits 6 and 7
   325 					.else
   326 						and #$80	//In case of 16 kb banks just take bit 7
   327
   328 					.endif
   329 0425 4A 4A 4A 4A 4A 4A		:6 lsr		// Move it to bit 0 and 1!
   330 					.if FLAG_16KB = 1
   331 						lsr	// Or bit 7 to 0 in case of 16kb banks
   332 					.endif
   333 042B 85 34			sta aux1	// Store it!
   334 042D A5 35			lda aux2	// Take MSB of the sector.
   335 042F 0A				asl		// Move 2 bits to the left! Bits 0 and 1 are zero 
   336 					.if FLAG_16KB = 0 //Or 1 bit if it's a Megacart
   337 0430 0A					asl		// Done!
   338 					.endif
   339 0431 05 34			ora aux1	// Put bits 0 and 1 on from the previous calculation 
   340 0433 18				clc		// Preparing to add 1
   341 = 0435			parameter=*+1		// IMPORTANT: the parameter sets the initial side from the disk. Originally, 1
   342 0434 69 01			adc #$01	// Add it!
   343 0436 85 36			sta c_bank	// Store cartridge bank!
   344 0438 68				pla		// take previous LSB of the sector number.
   345 					.if FLAG_16KB = 0
   346 0439 29 3F				and #$3F	// Take bits from 0 to 5. Bits 6 and 7 were previously taken to calculate the cartridge bank.
   347 					.else
   348 						and #$7f	// Take bits from 0 to 6. Bit 7 was previously taken to calculate the cartridge bank
   349 					.endif
   350 043B 4A				lsr		// Shift bit 0 to carry flag. That way, we'll know if the LSB to read on the cartridge is $00 or $80
   351 043C 09 A0			ora #>start_cartridge	// Establish the initial address from the cartridge
   352 043E 85 35			sta aux2	// Store it as MSB from the address to read from the cartridge
   353 0440 A9 00			lda #$00	// Taking carry
   354 0442 6A				ror		// To determine if LSB is $00 or $80
   355 0443 85 34			sta aux1	// Save it!
   356 0445 A0 7F			ldy #$7F	// Number of bytes to read from cartridge (128)
   357 0447			loop
   358 0447 A5 36			lda c_bank	// First, we take the cartridge bank calculated
   359 0449 AA				tax		// Transfer to register X
   360 044A 9D 00 D5			sta $d500,x	// And save to the cartridge control area. This way I can use Data bus or address bus bank-switching methods 
   361 044D B1 34			lda (aux1),y	// Read the byte from the cartridge
   362 044F 48				pha		// Store it before turning off the cartridge
   363 0450 A9 FF			lda #$FF	// Let's turn the cartridge off
   364 = 0453			flag = *+1
   365 0452 8D FF D5			sta cart_apaga	// Done!
   366 0455 68				pla		// Recover byte reading
   367 0456 91 32			sta (bufrlo),y	// Store it to the final address
   368 0458 88				dey		// Are we done with the byte copying?
   369 0459 10 EC			bpl loop	// Not yet
   370 045B A9 C0			lda #$c0	// Ending the cartridge reading process. Now we recover the computer status
   371 045D 8D 0E D4			sta nmien	// Recover NMIs
   372 0460 58				cli		// Recover IRQs
   373 0461 A0 01			ldy #$01	// All done without errors
   374 0463 8C 03 03			sty dstats	// Save it to DSTATS!
   375 0466 60				rts		// BYE!!
   376 0467			fin_loader
   377 				.endp
   378
   379 A3DF			Copy_loader2
   380 A3DF			.proc	loader2 , start_loader2
   381
   382 				;aux1 = $02
   383 				;aux2 = aux1+1
   384 = 0230			drivenum =$230
   385 = 0231			drivecommand =$231
   386 = 0232			driveseclo =$232
   387 = 0233			drivesechi =$233
   388 = 023D			status1 = $23d
   389 = 0246			status2 = $246
   390 = 0100			buffer = $100
   391 = CFF0			backupbuffer =$cff0
   392
   393 				//	lda drivecommand
   394 				//	cmp #$53 	//status command?
   395 				//	beq go_drive1
   396 CC00 AD 30 02			lda drivenum
   397 CC03 C9 31			cmp #$31	//Is it drive 1?
   398 CC05 D0 17			jne no_drive1	//No!
   399 CC07 20 4E 20			jsr $204e		//Go to normal SIO routine
   400 CC0A 10 11			bpl end_drive1	//Is there an error?
   401 CC0C 08				php				//Yes! We have an error.
   402 CC0D AD 31 02			lda drivecommand
   403 CC10 C9 53			cmp #$53		//Is it a status instruction?
   404 CC12 D0 02			bne no_status	//No, change drive to D2:
   405 CC14 28				plp
   406 CC15 60				rts
   407 CC16			no_status
   408 CC16 EE 30 02			inc drivenum	//change drive to D2:
   409 CC19 28				plp				//Restore Processor Status
   410 CC1A 4C 00 CC			jmp loader2		//Go again!
   411 CC1D			end_drive1
   412 CC1D 60				rts
   413 CC1E			no_drive1
   414 CC1E C9 34			cmp #$34	//Is virtual D4: drive?
   415 CC20 F0 03 4C 2E CD		jne drive2	//No! It's the character disk.
   416 				//	beq drive4
   417 				//	jmp $204e	// Use the disk drive!!!
   418 CC25			drive4	
   419 CC25 78				sei		// No IRQs!
   420 CC26 A9 00			lda #$00	
   421 CC28 8D 0E D4			sta nmien	// No NMIs!
   422
   423 CC2B 38				sec		// Let's substract 1
   424 CC2C AD 32 02			lda driveseclo	// To the sector number!
   425 CC2F E9 01			sbc #$01
   426 CC31 8D 72 CC			sta d4_aux1	// Store it!
   427 CC34 AD 33 02			lda drivesechi	// Take MSB of the sector to read
   428 CC37 E9 00			sbc #$00	// Make sure we store it
   429 CC39 8D 73 CC			sta d4_aux2	// on page zero!
   430 CC3C 18				clc		// Clear the carry.
   431 CC3D AD 72 CC			lda d4_aux1	// Take new sector number
   432 CC40 48				pha		// save it!
   433 					.if FLAG_16KB = 0
   434 CC41 29 C0				and #$c0	// Take bits 6 and 7
   435 					.else
   436 						and #$80	//In case of 16 kb banks just take bit 7
   437
   438 					.endif
   439 CC43 4A 4A 4A 4A 4A 4A		:6 lsr		// Move it to bit 0 and 1!
   440 					.if FLAG_16KB = 1
   441 						lsr	// Or bit 7 to 0 in case of 16kb banks
   442 					.endif
   443 CC49 8D 72 CC			sta d4_aux1	// Store it!
   444 CC4C AD 73 CC			lda d4_aux2	// Take MSB of the sector.
   445 CC4F 0A				asl		// Move 2 bits to the left! Bits 0 and 1 are zero 
   446 					.if FLAG_16KB = 0 //Or 1 bit if it's a Megacart
   447 CC50 0A					asl		// Done!
   448 					.endif
   449 CC51 0D 72 CC			ora d4_aux1	// Put bits 0 and 1 on from the previous calculation 
   450 CC54 18				clc		// Preparing to add 1
   451 = CC56			d4_parameter=*+1	// IMPORTANT: the parameter sets the initial side from the disk. Originally, 1
   452 CC55 69 01			adc #$01	// Add it!
   453 CC57 8D 6C CC			sta d4_c_bank	// Store cartridge bank!
   454 CC5A 68				pla		// take previous LSB of the sector number.
   455 					.if FLAG_16KB = 0
   456 CC5B 29 3F				and #$3F	// Take bits from 0 to 5. Bits 6 and 7 were previously taken to calculate the cartridge bank.
   457 					.else
   458 						and #$7f	// Take bits from 0 to 6. Bit 7 was previously taken to calculate the cartridge bank
   459 					.endif
   460 CC5D 4A				lsr		// Shift bit 0 to carry flag. That way, we'll know if the LSB to read on the cartridge is $00 or $80
   461 CC5E 09 A0			ora #>start_cartridge	// Establish the initial address from the cartridge
   462 CC60 8D 73 CC			sta d4_aux2	// Store it as MSB from the address to read from the cartridge
   463 CC63 A9 00			lda #$00	// Taking carry
   464 CC65 6A				ror		// To determine if LSB is $00 or $80
   465 CC66 8D 72 CC			sta d4_aux1	// Save it!
   466 CC69 A0 7F			ldy #$7F	// Number of bytes to read from cartridge (128)
   467 CC6B			d4_ldacbank
   468 CC6B A9 FF			lda #$FF	// First, we take the cartridge bank calculated
   469 = CC6C			d4_c_bank = d4_ldacbank+1
   470 CC6D AA				tax		// Transfer to register X
   471 CC6E 9D 00 D5			sta $d500,x	// And save to the cartridge control area. This way I can use Data bus or address bus bank-switching methods 
   472 CC71			d4_loop
   473 CC71 B9 FF FF			lda $FFFF,y	// Read the byte from the cartridge
   474 = CC72			d4_aux1 = d4_loop+1
   475 = CC73			d4_aux2 = d4_aux1+1
   476 CC74 99 00 01			sta buffer,y	// Store it to the final address
   477 CC77 88				dey		// Are we done with the byte copying?
   478 CC78 10 F7			bpl d4_loop	// Not yet
   479 CC7A A9 FF			lda #$ff
   480 CC7C 8D FF D5			sta cart_apaga
   481 CC7F A9 C0			lda #$c0	// Ending the cartridge reading process. Now we recover the computer status
   482 CC81 8D 0E D4			sta nmien	// Recover NMIs
   483 CC84 58				cli		// Recover IRQs
   484
   485
   486 				//Let's patch the SPACE BAR for character disk
   487 CC85 AD BE 7E			lda $7ebe
   488 CC88 C9 30			cmp #$30
   489 CC8A D0 16			bne d4_2nd
   490 CC8C AD BF 7E			lda $7ebf
   491 CC8F C9 FB			cmp #$fb
   492 CC91 D0 0F			bne d4_2nd
   493 					
   494 				//Let's patch the SPACE BAR from the first menu!	
   495 CC93 A9 4C			lda #$4c
   496 CC95 8D BE 7E			sta $7ebe
   497 CC98 A9 CB			lda #$cb
   498 CC9A 8D BF 7E			sta $7ebf
   499 CC9D A9 7E			lda #$7e
   500 CC9F 8D C0 7E			sta $7ec0
   501 					
   502 CCA2			d4_2nd
   503 CCA2 AD 2F 76			lda $762f
   504 CCA5 C9 30			cmp #$30
   505 CCA7 D0 0F			bne d4_3rd
   506 CCA9 AD 30 76			lda $7630
   507 CCAC C9 FB			cmp #$fb
   508 CCAE D0 08			bne d4_3rd
   509 				//Let's patch the SPACE BAR from saving the character during the game
   510 CCB0 A9 EA			lda #$ea
   511 CCB2 8D 2F 76			sta $762f
   512 CCB5 8D 30 76			sta $7630
   513 CCB8			d4_3rd
   514 CCB8 AD 08 76			lda $7608
   515 CCBB C9 20			cmp #$20	//JSR?
   516 CCBD D0 16			bne d4_4th	//No!
   517 CCBF A9 18			lda #$18
   518 CCC1 CD 09 76			cmp $7609
   519 CCC4 D0 0F			bne d4_4th
   520 CCC6 CD 0A 76			cmp $760a
   521 CCC9 D0 0A			bne d4_4th
   522 CCCB A9 3A 8D 09 76 A9 + 	mwa #put_31 $7609
   523 CCD5			d4_4th
   524 CCD5 AD 04 84			lda $8404
   525 CCD8 C9 A9			cmp #$A9	//LDA?
   526 CCDA D0 11			bne d4_5th
   527 CCDC AD 05 84			lda $8405
   528 CCDF C9 31			cmp #$31	//Drive 1?
   529 CCE1 D0 0A			bne d4_5th	//Nope!
   530 CCE3 A9 42 8D 02 84 A9 + 	mwa #char_format $8402
   531 CCED			d4_5th
   532 CCED AD BF 77			lda $77bf
   533 CCF0 C9 A9			cmp #$a9
   534 CCF2 D0 12			bne d4_6th
   535 CCF4 AD C0 77			lda $77c0
   536 CCF7 C9 57			cmp #$57
   537 CCF9 D0 0B			bne d4_6th
   538 CCFB A9 50			lda #$50
   539 CCFD 8D 6C 77			sta $776c
   540 CD00 8D A3 77			sta $77a3
   541 CD03 8D C0 77			sta $77c0
   542 CD06			d4_6th
   543 CD06 AD 2F 78			lda $782f
   544 CD09 C9 4C			cmp #$4c
   545 CD0B D0 18			bne d4_end
   546 CD0D AD 30 78			lda $7830
   547 CD10 C9 21			cmp #$21
   548 CD12 D0 11			bne d4_end
   549 CD14 AD 31 78			lda $7831
   550 CD17 C9 76			cmp #$76
   551 CD19 D0 0A			bne d4_end
   552 CD1B A9 74 8D 30 78 A9 + 	mwa #patch_char $7830
   553
   554 CD25			d4_end
   555 CD25 A0 01			ldy #$01	// All done without errors
   556 CD27 8C 3D 02			sty status1	// Save it to DSTATS!
   557 CD2A 8C 46 02			sty status2
   558 CD2D 60				rts		// BYE!!
   559
   560 CD2E			drive2
   561 CD2E AD 31 02			lda drivecommand
   562 CD31 C9 21			cmp #$21	//Is it a format command?
   563 CD33 D0 27			jne no_format	//No! It's a write or read
   564
   565 				//Let's format it! Will erase all sectors for D1:
   566 CD35 A9 0A			lda #$0a
   567 CD37 20 E5 CE			jsr erasebk	//Erase bank $0a (Header info)
   568 CD3A A9 0B			lda #$0b
   569 CD3C 20 E5 CE			jsr erasebk	//Erase bank $0b (save state 1)
   570 CD3F A9 0C			lda #$0c
   571 CD41 20 E5 CE			jsr erasebk	//Erase bank $0c (save state 2)
   572 CD44 A9 0D			lda #$0d
   573 CD46 20 E5 CE			jsr erasebk	//Erase bank $0d (save state 3)
   574 CD49 A9 0E			lda #$0e
   575 CD4B 20 E5 CE			jsr erasebk	//Erase bank $0e (save state 4)
   576 CD4E A9 FF			lda #$ff
   577 CD50 8D FF D5			sta cart_apaga
   578 CD53 A0 01			ldy #$01	// All done without errors
   579 CD55 8C 3D 02			sty status1	// Save it to DSTATS!
   580 CD58 8C 46 02			sty status2
   581 CD5B 60				rts		//Formatting successful
   582 CD5C			no_format
   583
   584
   585 				//	rts		//NEED TO BE REMOVED!!!!
   586
   587
   588 CD5C 48				pha		//Store command for a while
   589 				//Now will check if it's the initial sector from the block of the disk.
   590 				//In case it's the initial one, it erases the entire sector
   591 CD5D A2 00			ldx #$00	//Counter
   592 CD5F 8E A2 CE			stx sector_selected
   593 CD62 A0 01			ldy #$01	//Start with no detection!!
   594 CD64			d2_loop1
   595 CD64 AD 33 02			lda drivesechi		//Take MSB of the sector
   596 CD67 DD 7D CE			cmp sec_table+1,x	//Is it from the table?
   597 CD6A F0 04			beq d2_loop1_0 
   598 CD6C 90 12			bcc d2_loop2		//NO! It's higher. Don't count this.
   599 CD6E D0 0D			bne d2_loop1_2		//No! It's lower. Take x to the sector selected.
   600
   601 CD70			d2_loop1_0
   602 CD70 AD 32 02			lda driveseclo		//It's equal. Now let's get LSB of the sector.
   603 CD73 DD 7C CE			cmp sec_table,x		//Is it from the table?
   604 CD76 F0 04			beq d2_loop1_1
   605 CD78 90 06			bcc d2_loop2		//No, it's higher. next sector!
   606 CD7A D0 01			bne d2_loop1_2		//No, it's lower. Take x to the sector selected.
   607 CD7C			d2_loop1_1
   608 CD7C 88				dey			//It's the same! Put Y = 0.
   609 CD7D			d2_loop1_2
   610 CD7D 8E A2 CE			stx sector_selected
   611 CD80			d2_loop2
   612 CD80 E8				inx
   613 CD81 E8				inx
   614 CD82 E0 0A			cpx #$0a	//All 5 sectors checked?
   615 CD84 D0 DE			bne d2_loop1	//Not yet!
   616 CD86 AE A2 CE			ldx sector_selected
   617 CD89 BD 86 CE			lda offset_table,x	//Take the offset
   618 CD8C 8D 90 CE			sta sec_offset		//Store it!
   619 CD8F BD 87 CE			lda offset_table+1,x	//MSB offset
   620 CD92 8D 91 CE			sta sec_offset+1	//Store it!
   621 CD95 4E A2 CE			lsr sector_selected
   622 CD98 AE A2 CE			ldx sector_selected
   623 CD9B BD 9C CE			lda bank_table,x
   624 CD9E 8D D4 CD			sta d2_parameter	//Change initial bank to take
   625
   626 CDA1			drive2_put
   627 CDA1 78				sei		// No IRQs!
   628 CDA2 A9 00			lda #$00	
   629 CDA4 8D 0E D4			sta nmien	// No NMIs!
   630
   631 CDA7 38				sec		// Let's substract the offset
   632 CDA8 AD 32 02			lda driveseclo	// To the sector number!
   633 CDAB ED 90 CE			sbc sec_offset
   634 CDAE 8D 02 CE			sta d2_read_aux1	// Store it!
   635 CDB1 AD 33 02			lda drivesechi	// Take MSB of the sector to read
   636 CDB4 ED 91 CE			sbc sec_offset+1	// Make sure we store it
   637 CDB7 8D 03 CE			sta d2_read_aux2	// on page zero!
   638 CDBA 18				clc		// Clear the carry.
   639 CDBB AD 02 CE			lda d2_read_aux1	// Take new sector number
   640 CDBE 48				pha		// save it!
   641 CDBF 29 C0			and #$c0	// Take bits 6 and 7
   642 CDC1 4A 4A 4A 4A 4A 4A		:6 lsr		// Move it to bit 0 and 1!
   643 CDC7 8D 02 CE			sta d2_read_aux1	// Store it!
   644 CDCA AD 03 CE			lda d2_read_aux2	// Take MSB of the sector.
   645 CDCD 0A				asl		// Move 2 bits to the left! Bits 0 and 1 are zero 
   646 CDCE 0A				asl		// Done!
   647 CDCF 0D 02 CE			ora d2_read_aux1	// Put bits 0 and 1 on from the previous calculation 
   648 CDD2 18				clc		// Preparing to add the bank parameter
   649 = CDD4			d2_parameter=*+1	// IMPORTANT: the parameter sets the initial side from the disk. Originally, 1
   650 CDD3 69 01			adc #$01	// Add it!
   651 CDD5 8D FC CD			sta d2_read_c_bank	// Store cartridge bank!
   652 CDD8 8D 19 CE			sta d2_write_c_bank
   653 CDDB 68				pla		// take previous LSB of the sector number.
   654 CDDC 29 3F			and #$3F	// Take bits from 0 to 5. Bits 6 and 7 were previously taken to calculate the cartridge bank.
   655 CDDE 4A				lsr		// Shift bit 0 to carry flag. That way, we'll know if the LSB to read on the cartridge is $00 or $80
   656 CDDF 09 A0			ora #>start_cartridge	// Establish the initial address from the cartridge
   657 CDE1 8D 03 CE			sta d2_read_aux2	// Store it as MSB from the address to read from the cartridge
   658 CDE4 8D 22 CE			sta d2_write_aux2
   659 CDE7 A9 00			lda #$00	// Taking carry
   660 CDE9 6A				ror		// To determine if LSB is $00 or $80
   661 CDEA 8D 02 CE			sta d2_read_aux1	// Save it!
   662 CDED 8D 21 CE			sta d2_write_aux1
   663
   664 				//Now we start to copy the bytes (read/write)
   665
   666 CDF0 A2 7F			ldx #$7f
   667 CDF2 68				pla		//Restore command
   668 CDF3 C9 57			cmp #$57	//Write?
   669 CDF5 F0 15			beq d2_write
   670 CDF7 C9 50			cmp #$50
   671 CDF9 F0 11			beq d2_write
   672 CDFB			d2_read_ldacbank
   673 CDFB A9 FF			lda #$ff
   674 = CDFC			d2_read_c_bank =d2_read_ldacbank+1
   675 CDFD A8				tay
   676 CDFE 99 00 D5			sta $d500,y
   677 CE01			d2_read_loop
   678 CE01 BD FF FF			lda $FFFF,x	// Read the byte from the cartridge
   679 = CE02			d2_read_aux1 = d2_read_loop+1
   680 = CE03			d2_read_aux2 = d2_read_aux1+1
   681 CE04 9D 00 01			sta buffer,x	// Store it to the final address
   682 CE07 CA				dex		// Are we done with the byte copying?
   683 CE08 10 F7			bpl d2_read_loop	// Not yet
   684 CE0A 30 1A			bmi d2_end	//Let's finish
   685
   686 CE0C			d2_write
   687 CE0C 98				tya		//Is is first sector?
   688 CE0D D0 09			bne d2_write_cont	//Nope, let's continue
   689 CE0F AD A2 CE			lda sector_selected	
   690 CE12 18				clc
   691 CE13 69 0A			adc #$0a
   692 CE15 20 E5 CE			jsr erasebk		//Erase the bank and start writing!
   693 CE18			d2_write_cont
   694
   695 CE18			d2_write_loop
   696 CE18			d2_write_ldacbank
   697 CE18 A9 FF			lda #$ff
   698 = CE19			d2_write_c_bank =d2_write_ldacbank+1
   699 CE1A 20 C4 CE			jsr enable_write
   700 CE1D BD 00 01			lda buffer,x
   701 CE20			d2_write_sta	
   702 CE20 9D FF FF			sta $FFFF,x
   703 = CE21			d2_write_aux1 = d2_write_sta+1
   704 = CE22			d2_write_aux2 = d2_write_aux1+1
   705 CE23 CA				dex
   706 CE24 10 F2			bpl d2_write_loop
   707
   708 CE26			d2_end
   709 CE26 A9 FF			lda #$ff
   710 CE28 8D FF D5			sta cart_apaga
   711 CE2B A9 C0			lda #$c0	// Ending the cartridge reading process. Now we recover the computer status
   712 CE2D 8D 0E D4			sta nmien	// Recover NMIs
   713 CE30 58				cli		// Recover IRQs
   714 CE31 A0 01			ldy #$01	// All done without errors
   715 CE33 8C 3D 02			sty status1	// Save it to DSTATS!
   716 CE36 8C 46 02			sty status2
   717 CE39 60				rts		// BYE!!
   718
   719 CE3A			put_31
   720 CE3A A9 31			lda #$31	//Put D1: first
   721 CE3C 8D 30 02			sta drivenum	
   722 CE3F 4C 18 18			jmp $1818	//Go!
   723
   724 CE42			char_format
   725 CE42 20 27 18			jsr $1827
   726 CE45 A2 31			ldx #$31
   727 CE47 AD 4E 02			lda $24e
   728 CE4A 10 01			bpl char_format_si31
   729 CE4C E8				inx
   730 CE4D			char_format_si31
   731 CE4D 8E 05 84			stx $8405	//Store drive number
   732 CE50 A9 4C			lda #$4c
   733 CE52 8D 21 84			sta $8421
   734 CE55 A9 60 8D 22 84 A9 + 	mwa #char_format_error $8422	//Patch format error.
   735 CE5F 60				rts
   736
   737 CE60			char_format_error
   738 CE60 A9 FE			lda #$fe
   739 CE62 85 16			sta $16
   740 CE64 AD 30 02			lda $230
   741 CE67 C9 31			cmp #$31
   742 CE69 F0 03			beq char_format_error_31
   743 CE6B 4C 25 84			jmp $8425
   744 CE6E			char_format_error_31
   745 CE6E EE 30 02			inc $230
   746 CE71 4C 09 84			jmp $8409
   747
   748 CE74			patch_char
   749 CE74 A9 31			lda #$31
   750 CE76 8D 30 02			sta drivenum
   751 CE79 4C 31 76			jmp $7631
   752
   753 CE7C			sec_table		//List of initial sectors to write on 
   754
   755 				//This table marks the sectors we'll take into account to erase the entire sector.
   756 				//That is, the initial disk sector from we'll erase.
   757 CE7C 02 00 03 00 BB 00 + 	.word $0002,$0003,$00bb,$0173,$022b
   758 CE86			offset_table
   759 CE86 01 00 03 00 BB 00 + 	.word $0001,$0003,$00bb,$0173,$022b
   760 CE90			sec_offset
   761 CE90 00 00			.word $0000	//Sector offset to substract from original cartridge sector.
   762 				//bank_table		//List of initial bank per sector. The first 10 sectors are for D4:. Banks $0a-$0f to D1:
   763 CE92 00 00 00 00 00 00 + 	.by $00,$00,$00,$00,$00,$00,$00,$00,$00,$00
   764 CE9C			bank_table
   765 CE9C 50 58 60 68 70 78		.by $50,$58,$60,$68,$70,$78
   766 CEA2			sector_selected
   767 CEA2 00				.by $00		//By default, sector 0
   768 CEA3			bank_selected
   769 CEA3 00				.by $00		//By default, bank 0
   770
   771 				//Code for managing the Atarimax flash cartridge. Please take note that this routine
   772 				//is implemented just for the second chip.
   773 				//To add functionality to the first chip, you must change the wr5555, wr2aaa and add a chip mask routine.
   774
   775
   776 CEA4			fcode
   777 CEA4			setsec
   778 CEA4 29 0F			and #$0F	//Only $00-$0F allowed
   779 CEA6 18				clc		//Just to not set bit 7 to 1 accidentally
   780 CEA7 2A				rol		//*2
   781 CEA8 2A				rol		//*4
   782 CEA9 2A				rol		//*8
   783 CEAA AA				tax
   784 CEAB 9D 00 D5			sta $d500,x	//Change bank!
   785 CEAE 60				rts
   786
   787 CEAF			wr5555
   788 CEAF 8D 42 D5			sta $d542	//Setting third bank from second chip.
   789 CEB2 8D 55 B5			sta $b555	//Store on $5555!
   790 CEB5 60				rts
   791
   792 CEB6			cmd_unlock
   793 CEB6 A9 AA			lda #$AA	//Store $aa on $5555
   794 CEB8 20 AF CE			jsr wr5555	//Do it!
   795 CEBB A9 55			lda #$55	//Store $55 on $2aaa
   796
   797 CEBD			wr2AAA
   798 CEBD 8D 41 D5			sta $d541	//Setting second bank from second chip.
   799 CEC0 8D AA AA			sta $aaaa	//Store on $2aaa
   800 CEC3 60				rts
   801
   802
   803 				//Enable_write:
   804 				//enables the 29F040 chip to write one byte.
   805 				//It only enables one byte. You have to call this routine for every byte you want to write.
   806 CEC4			enable_write
   807 CEC4 8E 23 CF			stx temp_x
   808 CEC7 48				pha
   809 CEC8 20 B6 CE			jsr cmd_unlock	//First and second cycle
   810 CECB A9 A0			lda #$a0
   811 CECD 20 AF CE			jsr wr5555	//Third cycle
   812 CED0			enable_write_cont
   813 CED0 68				pla
   814 CED1 AA				tax
   815 CED2 9D 00 D5			sta $d500,x
   816 CED5 AE 23 CF			ldx temp_x
   817 CED8 60				rts
   818
   819 				//Enable read: not needed for now. Just to have it.
   820 CED9			enable_read
   821 CED9 48				pha
   822 CEDA 20 B6 CE			jsr cmd_unlock
   823 CEDD A9 F0			lda #$f0
   824 CEDF 20 AF CE			jsr wr5555
   825 CEE2 4C D0 CE			jmp enable_write_cont
   826 CEE5			erasebk
   827 CEE5 8E 23 CF			stx temp_x
   828 CEE8 48				pha
   829 CEE9 20 B6 CE			jsr cmd_unlock		//First two cycles!
   830 CEEC A9 80			lda #$80
   831 CEEE 20 AF CE			jsr wr5555		//Third cycle!
   832 CEF1 20 B6 CE			jsr cmd_unlock		//Fourth and fifth cycles!
   833 CEF4 68				pla
   834 CEF5 20 A4 CE			jsr setsec
   835 CEF8 A9 30			lda #$30		//Sixth and final cycle!
   836 CEFA 8D 00 A0			sta start_cartridge	//Erase!
   837 					
   838 				//Poll_write: wait until the erase is finished.
   839 CEFD			poll_write
   840 CEFD A9 00			lda #$00
   841 CEFF 8D 22 CF			sta pollsame
   842 CF02			@poll_again
   843 CF02 AD 00 A0			lda start_cartridge
   844 CF05 CD 00 A0			cmp start_cartridge
   845 CF08 D0 F3			bne poll_write
   846 CF0A CD 00 A0			cmp start_cartridge
   847 CF0D D0 EE			bne poll_write
   848 CF0F CD 00 A0			cmp start_cartridge
   849 CF12 D0 E9			bne poll_write
   850 CF14 EE 22 CF			inc pollsame
   851 CF17 D0 E9			bne @poll_again
   852 CF19 A9 FF			lda #$ff
   853 CF1B 8D FF D5			sta cart_apaga
   854 CF1E AE 23 CF			ldx temp_x
   855 CF21 60				rts
   856 CF22			pollsame
   857 CF22 00				.by $00
   858 CF23 00			temp_x	.by $00
   859 					
   860 				//	icl "fcode.s"	//Courtesy from Wrathchild at Atariage. Thanks!
   861
   862 CF24			chipmask
   863 CF24 00				.by $00
   864 CF25			final_greeting
   865 CF25 43 61 72 74 72 69 + 	.by "Cartridge version 2020 by Guillermo Fuenzalida, based on the works from Mark Keates"
   866 CF78			fin_loader
   867 				.endp
   868
   869 					opt f+		//start filling!
   870 					
   871 A757				org end_bank-6-3	//// Put it into the end
   872 BFF7 4C 00 A0			jmp init
   873 BFFA 23 A0			.word init1		// Second init address first.
   874 BFFC 00 04			.byte $00,$04		// Parameters to not to call to Disk.
   875 BFFE 00 A0			.word init		// First init address
   876 					opt f-			// No more filling!
   877
   878 				// Bank 2
   879 C000				org start_cartridge
   880 01,A000				lmb #$01
   881 01,A000			start_atr
   882 01,A000 01 01 00 06 06 + 	ins "ARD_WIP_rel3.atr",16
   883 01,09A000		end_atr
   884
   885 				//Now we fill till we got cartridge size
   886
   887 = 01,090000		total_bytes	= end_atr - start_atr		//Total bytes of ATR
   888 = 01,2000		bank_size	= end_bank - start_cartridge
   889
   890 = 01,0049		banks_used = ((total_bytes+(bank_size-1))/bank_size)+1
   891 = 01,0037		filler_banks = cart_banks - banks_used
   892 = 01,0000		filler_bytes = bank_size*(banks_used-1)-total_bytes
   893
   894 				; Llenamos los bytes
   895
   896 				.if filler_banks > 0
   897 01,09A000			.sav filler_bytes
   898 				.else
   899 					.sav filler_bytes - 6 -8
   900 				.endif
   901
   902 01,09A000		end_file
   903
   904
   905 				.if filler_banks > 0
   906 					.if filler_banks > 1
   907 						.rept filler_banks-1
   908 							.SAV BANK_SIZE
   909 						.ENDR
   909 						.endr
Source: REPT
   908 01,09A000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,09C000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,09E000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0A0000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0A2000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0A4000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0A6000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0A8000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0AA000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0AC000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0AE000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0B0000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0B2000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0B4000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0B6000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0B8000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0BA000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0BC000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0BE000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0C0000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0C2000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0C4000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0C6000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0C8000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0CA000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0CC000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0CE000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0D0000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0D2000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0D4000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0D6000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0D8000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0DA000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0DC000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0DE000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0E0000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0E2000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0E4000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0E6000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0E8000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0EA000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0EC000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0EE000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0F0000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0F2000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0F4000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0F6000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0F8000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0FA000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0FC000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,0FE000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,100000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,102000 00 00 00 00 +  			.SAV BANK_SIZE
   908 01,104000 00 00 00 00 +  			.SAV BANK_SIZE
Source: C:\Users\admin\OneDrive\Guille\Eclipse\workplace\WUDSN\GitHub\ARDungeonCartridge\BOOTCartridge\Alternate Reality - The dungeon\Ardungeon.asm
   910 					.endif
   911 01,106000 00 00 00 00 +  	.sav bank_size-6-8
   912 				.endif
   913
   914
   915 01,107FF2 A9 00			lda #$00
   916 01,107FF4 8D 00 D5		sta $d500
   917 01,107FF7 4C 00 A0		jmp init
   918 01,107FFA 23 A0			.word init1
   919 01,107FFC 00 04			.byte $00,$04
   920 01,107FFE F2 BF			.word $bff2
